// Generated by typings
// Source: node_modules/@angular/core/src/metadata/di.d.ts
declare module '~@angular/core/src/metadata/di' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { InjectionToken } from '~@angular/core/src/di/injection_token';
import { Type } from '~@angular/core/src/type';
/**
 * This token can be used to create a virtual provider that will populate the
 * `entryComponents` fields of components and ng modules based on its `useValue`.
 * All components that are referenced in the `useValue` value (either directly
 * or in a nested array or map) will be added to the `entryComponents` property.
 *
 * ### Example
 * The following example shows how the router can populate the `entryComponents`
 * field of an NgModule based on the router configuration which refers
 * to components.
 *
 * ```typescript
 * // helper function inside the router
 * function provideRoutes(routes) {
 *   return [
 *     {provide: ROUTES, useValue: routes},
 *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
 *   ];
 * }
 *
 * // user code
 * let routes = [
 *   {path: '/root', component: RootComp},
 *   {path: '/teams', component: TeamsComp}
 * ];
 *
 * @NgModule({
 *   providers: [provideRoutes(routes)]
 * })
 * class ModuleWithRoutes {}
 * ```
 *
 * @experimental
 */
export const ANALYZE_FOR_ENTRY_COMPONENTS: InjectionToken<any>;
/**
 * Type of the Attribute decorator / constructor function.
 *
 * @stable
 */
export interface AttributeDecorator {
    /**
     * Specifies that a constant attribute value should be injected.
     *
     * The directive can inject constant string literals of host element attributes.
     *
     * ### Example
     *
     * Suppose we have an `<input>` element and want to know its `type`.
     *
     * ```html
     * <input type="text">
     * ```
     *
     * A decorator can inject string literal `text` like so:
     *
     * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}
     *
     * ### Example as TypeScript Decorator
     *
     * {@example core/ts/metadata/metadata.ts region='attributeFactory'}
     *
     * ### Example as ES5 DSL
     *
     * ```
     * var MyComponent = ng
     *   .Component({...})
     *   .Class({
     *     constructor: [new ng.Attribute('title'), function(title) {
     *       ...
     *     }]
     *   })
     * ```
     *
     * ### Example as ES5 annotation
     *
     * ```
     * var MyComponent = function(title) {
     *   ...
     * };
     *
     * MyComponent.annotations = [
     *   new ng.Component({...})
     * ]
     * MyComponent.parameters = [
     *   [new ng.Attribute('title')]
     * ]
     * ```
     *
     * @stable
     */
    (name: string): any;
    new (name: string): Attribute;
}
/**
 * Type of the Attribute metadata.
 */
export interface Attribute {
    attributeName?: string;
}
/**
 * Attribute decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Attribute: AttributeDecorator;
/**
 * Type of the Query metadata.
 *
 * @stable
 */
export interface Query {
    descendants: boolean;
    first: boolean;
    read: any;
    isViewQuery: boolean;
    selector: any;
}
/**
 * Base class for query metadata.
 *
 * See {@link ContentChildren}, {@link ContentChild}, {@link ViewChildren}, {@link ViewChild} for
 * more information.
 *
 * @stable
 */
export abstract class Query {
}
/**
 * Type of the ContentChildren decorator / constructor function.
 *
 * See {@link ContentChildren}.
 *
 * @stable
 */
export interface ContentChildrenDecorator {
    /**
     * @whatItDoes Configures a content query.
     *
     * @howToUse
     *
     * {@example core/di/ts/contentChildren/content_children_howto.ts region='HowTo'}
     *
     * @description
     *
     * You can use ContentChildren to get the {@link QueryList} of elements or directives from the
     * content DOM. Any time a child element is added, removed, or moved, the query list will be
     * updated,
     * and the changes observable of the query list will emit a new value.
     *
     * Content queries are set before the `ngAfterContentInit` callback is called.
     *
     * **Metadata Properties**:
     *
     * * **selector** - the directive type or the name used for querying.
     * * **descendants** - include only direct children or all descendants.
     * * **read** - read a different token from the queried elements.
     *
     * Let's look at an example:
     *
     * {@example core/di/ts/contentChildren/content_children_example.ts region='Component'}
     *
     * **npm package**: `@angular/core`
     *
     * @stable
     * @Annotation
     */
    (selector: Type<any> | Function | string, {descendants, read}?: {
        descendants?: boolean;
        read?: any;
    }): any;
    new (selector: Type<any> | Function | string, {descendants, read}?: {
        descendants?: boolean;
        read?: any;
    }): Query;
}
/**
 * Type of the ContentChildren metadata.
 *
 * @stable
 * @Annotation
 */
export type ContentChildren = Query;
/**
 * ContentChildren decorator and metadata.
 *
 *  @stable
 *  @Annotation
 */
export const ContentChildren: ContentChildrenDecorator;
/**
 * Type of the ContentChild decorator / constructor function.
 *
 *
 * @stable
 */
export interface ContentChildDecorator {
    /**
     * @whatItDoes Configures a content query.
     *
     * @howToUse
     *
     * {@example core/di/ts/contentChild/content_child_howto.ts region='HowTo'}
     *
     * @description
     *
     * You can use ContentChild to get the first element or the directive matching the selector from
     * the content DOM. If the content DOM changes, and a new child matches the selector,
     * the property will be updated.
     *
     * Content queries are set before the `ngAfterContentInit` callback is called.
     *
     * **Metadata Properties**:
     *
     * * **selector** - the directive type or the name used for querying.
     * * **read** - read a different token from the queried element.
     *
     * Let's look at an example:
     *
     * {@example core/di/ts/contentChild/content_child_example.ts region='Component'}
     *
     * **npm package**: `@angular/core`
     *
     * @stable
     * @Annotation
     */
    (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): any;
    new (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): ContentChild;
}
/**
 * Type of the ContentChild metadata.
 *
 * See {@link ContentChild}.
 *
 * @stable
 */
export type ContentChild = Query;
/**
 * ContentChild decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const ContentChild: ContentChildDecorator;
/**
 * Type of the ViewChildren decorator / constructor function.
 *
 * See {@link ViewChildren}.
 *
 * @stable
 */
export interface ViewChildrenDecorator {
    /**
     * @whatItDoes Configures a view query.
     *
     * @howToUse
     *
     * {@example core/di/ts/viewChildren/view_children_howto.ts region='HowTo'}
     *
     * @description
     *
     * You can use ViewChildren to get the {@link QueryList} of elements or directives from the
     * view DOM. Any time a child element is added, removed, or moved, the query list will be updated,
     * and the changes observable of the query list will emit a new value.
     *
     * View queries are set before the `ngAfterViewInit` callback is called.
     *
     * **Metadata Properties**:
     *
     * * **selector** - the directive type or the name used for querying.
     * * **read** - read a different token from the queried elements.
     *
     * Let's look at an example:
     *
     * {@example core/di/ts/viewChildren/view_children_example.ts region='Component'}
     *
     * **npm package**: `@angular/core`
     *
     * @stable
     * @Annotation
     */
    (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): any;
    new (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): ViewChildren;
}
/**
 * Type of the ViewChildren metadata.
 *
 * @stable
 */
export type ViewChildren = Query;
/**
 * ViewChildren decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const ViewChildren: ViewChildrenDecorator;
/**
 * Type of the ViewChild decorator / constructor function.
 *
 * See {@link ViewChild}
 *
 * @stable
 */
export interface ViewChildDecorator {
    /**
     * @whatItDoes Configures a view query.
     *
     * @howToUse
     *
     * {@example core/di/ts/viewChild/view_child_howto.ts region='HowTo'}
     *
     * @description
     *
     * You can use ViewChild to get the first element or the directive matching the selector from the
     * view DOM. If the view DOM changes, and a new child matches the selector,
     * the property will be updated.
     *
     * View queries are set before the `ngAfterViewInit` callback is called.
     *
     * **Metadata Properties**:
     *
     * * **selector** - the directive type or the name used for querying.
     * * **read** - read a different token from the queried elements.
     *
     * {@example core/di/ts/viewChild/view_child_example.ts region='Component'}
     *
     * **npm package**: `@angular/core`
     *
     * @stable
     * @Annotation
     */
    (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): any;
    new (selector: Type<any> | Function | string, {read}?: {
        read?: any;
    }): ViewChild;
}
/**
 * Type of the ViewChild metadata.
 *
 * @stable
 */
export type ViewChild = Query;
/**
 * ViewChild decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const ViewChild: ViewChildDecorator;
}
declare module '@angular/core/src/metadata/di' {
export * from '~@angular/core/src/metadata/di';
}

// Generated by typings
// Source: node_modules/@angular/core/src/metadata/directives.d.ts
declare module '~@angular/core/src/metadata/directives' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy } from '~@angular/core/src/change_detection/constants';
import { Provider } from '~@angular/core/src/di';
import { Type } from '~@angular/core/src/type';
import { TypeDecorator } from '~@angular/core/src/util/decorators';
import { ViewEncapsulation } from '~@angular/core/src/metadata/view';
/**
 * Type of the Directive decorator / constructor function.
 *
 * @stable
 */
export interface DirectiveDecorator {
    /**
     * @whatItDoes Marks a class as an Angular directive and collects directive configuration
     * metadata.
     *
     * @howToUse
     *
     * ```
     * import {Directive} from '@angular/core';
     *
     * @Directive({
     *   selector: 'my-directive',
     * })
     * export class MyDirective {
     * }
     * ```
     *
     * @description
     *
     * Directive decorator allows you to mark a class as an Angular directive and provide additional
     * metadata that determines how the directive should be processed, instantiated and used at
     * runtime.
     *
     * Directives allow you to attach behavior to elements in the DOM..
     *
     * A directive must belong to an NgModule in order for it to be usable
     * by another directive, component, or application. To specify that a directive is a member of an
     * NgModule,
     * you should list it in the `declarations` field of that NgModule.
     *
     * In addition to the metadata configuration specified via the Directive decorator,
     * directives can control their runtime behavior by implementing various Life-Cycle hooks.
     *
     * **Metadata Properties:**
     *
     * * **exportAs** - name under which the component instance is exported in a template
     * * **host** - map of class property to host element bindings for events, properties and
     * attributes
     * * **inputs** - list of class property names to data-bind as component inputs
     * * **outputs** - list of class property names that expose output events that others can
     * subscribe to
     * * **providers** - list of providers available to this component and its children
     * * **queries** -  configure queries that can be injected into the component
     * * **selector** - css selector that identifies this component in a template
     *
     * @stable
     * @Annotation
     */
    (obj: Directive): TypeDecorator;
    /**
     * See the {@link Directive} decorator.
     */
    new (obj: Directive): Directive;
}
export interface Directive {
    /**
     * The CSS selector that triggers the instantiation of a directive.
     *
     * Angular only allows directives to trigger on CSS selectors that do not cross element
     * boundaries.
     *
     * `selector` may be declared as one of the following:
     *
     * - `element-name`: select by element name.
     * - `.class`: select by class name.
     * - `[attribute]`: select by attribute name.
     * - `[attribute=value]`: select by attribute name and value.
     * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.
     * - `selector1, selector2`: select if either `selector1` or `selector2` matches.
     *
     *
     * ### Example
     *
     * Suppose we have a directive with an `input[type=text]` selector.
     *
     * And the following HTML:
     *
     * ```html
     * <form>
     *   <input type="text">
     *   <input type="radio">
     * <form>
     * ```
     *
     * The directive would only be instantiated on the `<input type="text">` element.
     *
     */
    selector?: string;
    /**
     * Enumerates the set of data-bound input properties for a directive
     *
     * Angular automatically updates input properties during change detection.
     *
     * The `inputs` property defines a set of `directiveProperty` to `bindingProperty`
     * configuration:
     *
     * - `directiveProperty` specifies the component property where the value is written.
     * - `bindingProperty` specifies the DOM property where the value is read from.
     *
     * When `bindingProperty` is not provided, it is assumed to be equal to `directiveProperty`.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ivhfXY?p=preview))
     *
     * The following example creates a component with two data-bound properties.
     *
     * ```typescript
     * @Component({
     *   selector: 'bank-account',
     *   inputs: ['bankName', 'id: account-id'],
     *   template: `
     *     Bank Name: {{bankName}}
     *     Account Id: {{id}}
     *   `
     * })
     * class BankAccount {
     *   bankName: string;
     *   id: string;
     *
     *   // this property is not bound, and won't be automatically updated by Angular
     *   normalizedBankName: string;
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `
     *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
     *   `
     * })
     * class App {}
     * ```
     *
     */
    inputs?: string[];
    /**
     * Enumerates the set of event-bound output properties.
     *
     * When an output property emits an event, an event handler attached to that event
     * the template is invoked.
     *
     * The `outputs` property defines a set of `directiveProperty` to `bindingProperty`
     * configuration:
     *
     * - `directiveProperty` specifies the component property that emits events.
     * - `bindingProperty` specifies the DOM property the event handler is attached to.
     *
     * ### Example ([live demo](http://plnkr.co/edit/d5CNq7?p=preview))
     *
     * ```typescript
     * @Directive({
     *   selector: 'interval-dir',
     *   outputs: ['everySecond', 'five5Secs: everyFiveSeconds']
     * })
     * class IntervalDir {
     *   everySecond = new EventEmitter();
     *   five5Secs = new EventEmitter();
     *
     *   constructor() {
     *     setInterval(() => this.everySecond.emit("event"), 1000);
     *     setInterval(() => this.five5Secs.emit("event"), 5000);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `
     *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
     *     </interval-dir>
     *   `
     * })
     * class App {
     *   everySecond() { console.log('second'); }
     *   everyFiveSeconds() { console.log('five seconds'); }
     * }
     * ```
     *
     */
    outputs?: string[];
    /**
     * Specify the events, actions, properties and attributes related to the host element.
     *
     * ## Host Listeners
     *
     * Specifies which DOM events a directive listens to via a set of `(event)` to `method`
     * key-value pairs:
     *
     * - `event`: the DOM event that the directive listens to.
     * - `statement`: the statement to execute when the event occurs.
     * If the evaluation of the statement returns `false`, then `preventDefault`is applied on the DOM
     * event.
     *
     * To listen to global events, a target must be added to the event name.
     * The target can be `window`, `document` or `body`.
     *
     * When writing a directive event binding, you can also refer to the $event local variable.
     *
     * ### Example ([live demo](http://plnkr.co/edit/DlA5KU?p=preview))
     *
     * The following example declares a directive that attaches a click listener to the button and
     * counts clicks.
     *
     * ```typescript
     * @Directive({
     *   selector: 'button[counting]',
     *   host: {
     *     '(click)': 'onClick($event.target)'
     *   }
     * })
     * class CountClicks {
     *   numberOfClicks = 0;
     *
     *   onClick(btn) {
     *     console.log("button", btn, "number of clicks:", this.numberOfClicks++);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `<button counting>Increment</button>`
     * })
     * class App {}
     * ```
     *
     * ## Host Property Bindings
     *
     * Specifies which DOM properties a directive updates.
     *
     * Angular automatically checks host property bindings during change detection.
     * If a binding changes, it will update the host element of the directive.
     *
     * ### Example ([live demo](http://plnkr.co/edit/gNg0ED?p=preview))
     *
     * The following example creates a directive that sets the `valid` and `invalid` classes
     * on the DOM element that has ngModel directive on it.
     *
     * ```typescript
     * @Directive({
     *   selector: '[ngModel]',
     *   host: {
     *     '[class.valid]': 'valid',
     *     '[class.invalid]': 'invalid'
     *   }
     * })
     * class NgModelStatus {
     *   constructor(public control:NgModel) {}
     *   get valid { return this.control.valid; }
     *   get invalid { return this.control.invalid; }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `<input [(ngModel)]="prop">`
     * })
     * class App {
     *   prop;
     * }
     * ```
     *
     * ## Attributes
     *
     * Specifies static attributes that should be propagated to a host element.
     *
     * ### Example
     *
     * In this example using `my-button` directive (ex.: `<div my-button></div>`) on a host element
     * (here: `<div>` ) will ensure that this element will get the "button" role.
     *
     * ```typescript
     * @Directive({
     *   selector: '[my-button]',
     *   host: {
     *     'role': 'button'
     *   }
     * })
     * class MyButton {
     * }
     * ```
     */
    host?: {
        [key: string]: string;
    };
    /**
     * Defines the set of injectable objects that are visible to a Directive and its light DOM
     * children.
     *
     * ## Simple Example
     *
     * Here is an example of a class that can be injected:
     *
     * ```
     * class Greeter {
     *    greet(name:string) {
     *      return 'Hello ' + name + '!';
     *    }
     * }
     *
     * @Directive({
     *   selector: 'greet',
     *   providers: [
     *     Greeter
     *   ]
     * })
     * class HelloWorld {
     *   greeter:Greeter;
     *
     *   constructor(greeter:Greeter) {
     *     this.greeter = greeter;
     *   }
     * }
     * ```
     */
    providers?: Provider[];
    /**
     * Defines the name that can be used in the template to assign this directive to a variable.
     *
     * ## Simple Example
     *
     * ```
     * @Directive({
     *   selector: 'child-dir',
     *   exportAs: 'child'
     * })
     * class ChildDir {
     * }
     *
     * @Component({
     *   selector: 'main',
     *   template: `<child-dir #c="child"></child-dir>`
     * })
     * class MainComponent {
     * }
     *
     * ```
     */
    exportAs?: string;
    /**
     * Configures the queries that will be injected into the directive.
     *
     * Content queries are set before the `ngAfterContentInit` callback is called.
     * View queries are set before the `ngAfterViewInit` callback is called.
     *
     * ### Example
     *
     * ```
     * @Component({
     *   selector: 'someDir',
     *   queries: {
     *     contentChildren: new ContentChildren(ChildDirective),
     *     viewChildren: new ViewChildren(ChildDirective)
     *   },
     *   template: '<child-directive></child-directive>'
     * })
     * class SomeDir {
     *   contentChildren: QueryList<ChildDirective>,
     *   viewChildren: QueryList<ChildDirective>
     *
     *   ngAfterContentInit() {
     *     // contentChildren is set
     *   }
     *
     *   ngAfterViewInit() {
     *     // viewChildren is set
     *   }
     * }
     * ```
     */
    queries?: {
        [key: string]: any;
    };
}
/**
 * Directive decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Directive: DirectiveDecorator;
/**
 * Type of the Component decorator / constructor function.
 *
 * @stable
 */
export interface ComponentDecorator {
    /**
     * @whatItDoes Marks a class as an Angular component and collects component configuration
     * metadata.
     *
     * @howToUse
     *
     * {@example core/ts/metadata/metadata.ts region='component'}
     *
     * @description
     * Component decorator allows you to mark a class as an Angular component and provide additional
     * metadata that determines how the component should be processed, instantiated and used at
     * runtime.
     *
     * Components are the most basic building block of an UI in an Angular application.
     * An Angular application is a tree of Angular components.
     * Angular components are a subset of directives. Unlike directives, components always have
     * a template and only one component can be instantiated per an element in a template.
     *
     * A component must belong to an NgModule in order for it to be usable
     * by another component or application. To specify that a component is a member of an NgModule,
     * you should list it in the `declarations` field of that NgModule.
     *
     * In addition to the metadata configuration specified via the Component decorator,
     * components can control their runtime behavior by implementing various Life-Cycle hooks.
     *
     * **Metadata Properties:**
     *
     * * **animations** - list of animations of this component
     * * **changeDetection** - change detection strategy used by this component
     * * **encapsulation** - style encapsulation strategy used by this component
     * * **entryComponents** - list of components that are dynamically inserted into the view of this
     *   component
     * * **exportAs** - name under which the component instance is exported in a template
     * * **host** - map of class property to host element bindings for events, properties and
     *   attributes
     * * **inputs** - list of class property names to data-bind as component inputs
     * * **interpolation** - custom interpolation markers used in this component's template
     * * **moduleId** - ES/CommonJS module id of the file in which this component is defined
     * * **outputs** - list of class property names that expose output events that others can
     *   subscribe to
     * * **providers** - list of providers available to this component and its children
     * * **queries** -  configure queries that can be injected into the component
     * * **selector** - css selector that identifies this component in a template
     * * **styleUrls** - list of urls to stylesheets to be applied to this component's view
     * * **styles** - inline-defined styles to be applied to this component's view
     * * **template** - inline-defined template for the view
     * * **templateUrl** - url to an external file containing a template for the view
     * * **viewProviders** - list of providers available to this component and its view children
     *
     * ### Example
     *
     * {@example core/ts/metadata/metadata.ts region='component'}
     *
     * @stable
     * @Annotation
     */
    (obj: Component): TypeDecorator;
    /**
     * See the {@link Component} decorator.
     */
    new (obj: Component): Component;
}
/**
 * Type of the Component metadata.
 *
 * @stable
 */
export interface Component extends Directive {
    /**
     * Defines the used change detection strategy.
     *
     * When a component is instantiated, Angular creates a change detector, which is responsible for
     * propagating the component's bindings.
     *
     * The `changeDetection` property defines, whether the change detection will be checked every time
     * or only when the component tells it to do so.
     */
    changeDetection?: ChangeDetectionStrategy;
    /**
     * Defines the set of injectable objects that are visible to its view DOM children.
     *
     * ## Simple Example
     *
     * Here is an example of a class that can be injected:
     *
     * ```
     * class Greeter {
     *    greet(name:string) {
     *      return 'Hello ' + name + '!';
     *    }
     * }
     *
     * @Directive({
     *   selector: 'needs-greeter'
     * })
     * class NeedsGreeter {
     *   greeter:Greeter;
     *
     *   constructor(greeter:Greeter) {
     *     this.greeter = greeter;
     *   }
     * }
     *
     * @Component({
     *   selector: 'greet',
     *   viewProviders: [
     *     Greeter
     *   ],
     *   template: `<needs-greeter></needs-greeter>`
     * })
     * class HelloWorld {
     * }
     *
     * ```
     */
    viewProviders?: Provider[];
    /**
     * The module id of the module that contains the component.
     * Needed to be able to resolve relative urls for templates and styles.
     * In CommonJS, this can always be set to `module.id`, similarly SystemJS exposes `__moduleName`
     * variable within each module.
     *
     *
     * ## Simple Example
     *
     * ```
     * @Directive({
     *   selector: 'someDir',
     *   moduleId: module.id
     * })
     * class SomeDir {
     * }
     *
     * ```
     */
    moduleId?: string;
    /**
     * Specifies a template URL for an Angular component.
     *
     *Only one of `templateUrl` or `template` can be defined per View.
     */
    templateUrl?: string;
    /**
     * Specifies an inline template for an Angular component.
     *
     * Only one of `templateUrl` or `template` can be defined per Component.
     */
    template?: string;
    /**
     * Specifies stylesheet URLs for an Angular component.
     */
    styleUrls?: string[];
    /**
     * Specifies inline stylesheets for an Angular component.
     */
    styles?: string[];
    /**
     * Animations are defined on components via an animation-like DSL. This DSL approach to describing
     * animations allows for a flexibility that both benefits developers and the framework.
     *
     * Animations work by listening on state changes that occur on an element within
     * the template. When a state change occurs, Angular can then take advantage and animate the
     * arc in between. This works similar to how CSS transitions work, however, by having a
     * programmatic DSL, animations are not limited to environments that are DOM-specific.
     * (Angular can also perform optimizations behind the scenes to make animations more performant.)
     *
     * For animations to be available for use, animation state changes are placed within
     * {@link trigger animation triggers} which are housed inside of the `animations` annotation
     * metadata. Within a trigger both {@link state state} and {@link transition transition} entries
     * can be placed.
     *
     * ```typescript
     * @Component({
     *   selector: 'animation-cmp',
     *   templateUrl: 'animation-cmp.html',
     *   animations: [
     *     // this here is our animation trigger that
     *     // will contain our state change animations.
     *     trigger('myTriggerName', [
     *       // the styles defined for the `on` and `off`
     *       // states declared below are persisted on the
     *       // element once the animation completes.
     *       state('on', style({ opacity: 1 }),
     *       state('off', style({ opacity: 0 }),
     *
     *       // this here is our animation that kicks off when
     *       // this state change jump is true
     *       transition('on => off', [
     *         animate("1s")
     *       ])
     *     ])
     *   ]
     * })
     * ```
     *
     * As depicted in the code above, a group of related animation states are all contained within
     * an animation `trigger` (the code example above called the trigger `myTriggerName`).
     * When a trigger is created then it can be bound onto an element within the component's
     * template via a property prefixed by an `@` symbol followed by trigger name and an expression
     * that
     * is used to determine the state value for that trigger.
     *
     * ```html
     * <!-- animation-cmp.html -->
     * <div @myTriggerName="expression">...</div>
     * ```
     *
     * For state changes to be executed, the `expression` value must change value from its existing
     * value
     * to something that we have set an animation to animate on (in the example above we are listening
     * to a change of state between `on` and `off`). The `expression` value attached to the trigger
     * must be something that can be evaluated with the template/component context.
     *
     * ### DSL Animation Functions
     *
     * Please visit each of the animation DSL functions listed below to gain a better understanding
     * of how and why they are used for crafting animations in Angular:
     *
     * - {@link trigger trigger()}
     * - {@link state state()}
     * - {@link transition transition()}
     * - {@link group group()}
     * - {@link sequence sequence()}
     * - {@link style style()}
     * - {@link animate animate()}
     * - {@link keyframes keyframes()}
     */
    animations?: any[];
    /**
     * Specifies how the template and the styles should be encapsulated:
     * - {@link ViewEncapsulation#Native `ViewEncapsulation.Native`} to use shadow roots - only works
     *   if natively available on the platform,
     * - {@link ViewEncapsulation#Emulated `ViewEncapsulation.Emulated`} to use shimmed CSS that
     *   emulates the native behavior,
     * - {@link ViewEncapsulation#None `ViewEncapsulation.None`} to use global CSS without any
     *   encapsulation.
     *
     * When no `encapsulation` is defined for the component, the default value from the
     * {@link CompilerOptions} is used. The default is `ViewEncapsulation.Emulated`}. Provide a new
     * `CompilerOptions` to override this value.
     *
     * If the encapsulation is set to `ViewEncapsulation.Emulated` and the component has no `styles`
     * nor `styleUrls` the encapsulation will automatically be switched to `ViewEncapsulation.None`.
     */
    encapsulation?: ViewEncapsulation;
    /**
     * Overrides the default encapsulation start and end delimiters (respectively `{{` and `}}`)
     */
    interpolation?: [string, string];
    /**
     * Defines the components that should be compiled as well when
     * this component is defined. For each components listed here,
     * Angular will create a {@link ComponentFactory} and store it in the
     * {@link ComponentFactoryResolver}.
     */
    entryComponents?: Array<Type<any> | any[]>;
}
/**
 * Component decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Component: ComponentDecorator;
/**
 * Type of the Pipe decorator / constructor function.
 *
 * @stable
 */
export interface PipeDecorator {
    /**
     * Declare reusable pipe function.
     *
     * A "pure" pipe is only re-evaluated when either the input or any of the arguments change.
     *
     * When not specified, pipes default to being pure.
     */
    (obj: Pipe): TypeDecorator;
    /**
     * See the {@link Pipe} decorator.
     */
    new (obj: Pipe): Pipe;
}
/**
 * Type of the Pipe metadata.
 *
 * @stable
 */
export interface Pipe {
    name: string;
    pure?: boolean;
}
/**
 * Pipe decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Pipe: PipeDecorator;
/**
 * Type of the Input decorator / constructor function.
 *
 * @stable
 */
export interface InputDecorator {
    /**
     * Declares a data-bound input property.
     *
     * Angular automatically updates data-bound properties during change detection.
     *
     * `Input` takes an optional parameter that specifies the name
     * used when instantiating a component in the template. When not provided,
     * the name of the decorated property is used.
     *
     * ### Example
     *
     * The following example creates a component with two input properties.
     *
     * ```typescript
     * @Component({
     *   selector: 'bank-account',
     *   template: `
     *     Bank Name: {{bankName}}
     *     Account Id: {{id}}
     *   `
     * })
     * class BankAccount {
     *   @Input() bankName: string;
     *   @Input('account-id') id: string;
     *
     *   // this property is not bound, and won't be automatically updated by Angular
     *   normalizedBankName: string;
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `
     *     <bank-account bank-name="RBC" account-id="4747"></bank-account>
     *   `
     * })
     *
     * class App {}
     * ```
     * @stable
     */
    (bindingPropertyName?: string): any;
    new (bindingPropertyName?: string): any;
}
/**
 * Type of the Input metadata.
 *
 * @stable
 */
export interface Input {
    /**
     * Name used when instantiating a component in the template.
     */
    bindingPropertyName?: string;
}
/**
 * Input decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Input: InputDecorator;
/**
 * Type of the Output decorator / constructor function.
 *
 * @stable
 */
export interface OutputDecorator {
    /**
     * Declares an event-bound output property.
     *
     * When an output property emits an event, an event handler attached to that event
     * the template is invoked.
     *
     * `Output` takes an optional parameter that specifies the name
     * used when instantiating a component in the template. When not provided,
     * the name of the decorated property is used.
     *
     * ### Example
     *
     * ```typescript
     * @Directive({
     *   selector: 'interval-dir',
     * })
     * class IntervalDir {
     *   @Output() everySecond = new EventEmitter();
     *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();
     *
     *   constructor() {
     *     setInterval(() => this.everySecond.emit("event"), 1000);
     *     setInterval(() => this.five5Secs.emit("event"), 5000);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `
     *     <interval-dir (everySecond)="everySecond()" (everyFiveSeconds)="everyFiveSeconds()">
     *     </interval-dir>
     *   `
     * })
     * class App {
     *   everySecond() { console.log('second'); }
     *   everyFiveSeconds() { console.log('five seconds'); }
     * }
     * ```
     * @stable
     */
    (bindingPropertyName?: string): any;
    new (bindingPropertyName?: string): any;
}
/**
 * Type of the Output metadata.
 *
 * @stable
 */
export interface Output {
    bindingPropertyName?: string;
}
/**
 * Output decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Output: OutputDecorator;
/**
 * Type of the HostBinding decorator / constructor function.
 *
 * @stable
 */
export interface HostBindingDecorator {
    /**
     * Declares a host property binding.
     *
     * Angular automatically checks host property bindings during change detection.
     * If a binding changes, it will update the host element of the directive.
     *
     * `HostBinding` takes an optional parameter that specifies the property
     * name of the host element that will be updated. When not provided,
     * the class property name is used.
     *
     * ### Example
     *
     * The following example creates a directive that sets the `valid` and `invalid` classes
     * on the DOM element that has ngModel directive on it.
     *
     * ```typescript
     * @Directive({selector: '[ngModel]'})
     * class NgModelStatus {
     *   constructor(public control:NgModel) {}
     *   @HostBinding('class.valid') get valid() { return this.control.valid; }
     *   @HostBinding('class.invalid') get invalid() { return this.control.invalid; }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: `<input [(ngModel)]="prop">`,
     * })
     * class App {
     *   prop;
     * }
     * ```
     * @stable
     */
    (hostPropertyName?: string): any;
    new (hostPropertyName?: string): any;
}
/**
 * Type of the HostBinding metadata.
 *
 * @stable
 */
export interface HostBinding {
    hostPropertyName?: string;
}
/**
 * HostBinding decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const HostBinding: HostBindingDecorator;
/**
 * Type of the HostListener decorator / constructor function.
 *
 * @stable
 */
export interface HostListenerDecorator {
    /**
     * Declares a host listener.
     *
     * Angular will invoke the decorated method when the host element emits the specified event.
     *
     * If the decorated method returns `false`, then `preventDefault` is applied on the DOM event.
     *
     * ### Example
     *
     * The following example declares a directive that attaches a click listener to the button and
     * counts clicks.
     *
     * ```typescript
     * @Directive({selector: 'button[counting]'})
     * class CountClicks {
     *   numberOfClicks = 0;
     *
     *   @HostListener('click', ['$event.target'])
     *   onClick(btn) {
     *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   template: '<button counting>Increment</button>',
     * })
     * class App {}
     * ```
     * @stable
     * @Annotation
     */
    (eventName: string, args?: string[]): any;
    new (eventName: string, args?: string[]): any;
}
/**
 * Type of the HostListener metadata.
 *
 * @stable
 */
export interface HostListener {
    eventName?: string;
    args?: string[];
}
/**
 * HostListener decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const HostListener: HostListenerDecorator;
}
declare module '@angular/core/src/metadata/directives' {
export * from '~@angular/core/src/metadata/directives';
}

// Generated by typings
// Source: node_modules/@angular/core/src/metadata/ng_module.d.ts
declare module '~@angular/core/src/metadata/ng_module' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Provider } from '~@angular/core/src/di';
import { Type } from '~@angular/core/src/type';
import { TypeDecorator } from '~@angular/core/src/util/decorators';
/**
 * A wrapper around a module that also includes the providers.
 *
 * @stable
 */
export interface ModuleWithProviders {
    ngModule: Type<any>;
    providers?: Provider[];
}
/**
 * Interface for schema definitions in @NgModules.
 *
 * @experimental
 */
export interface SchemaMetadata {
    name: string;
}
/**
 * Defines a schema that will allow:
 * - any non-Angular elements with a `-` in their name,
 * - any properties on elements with a `-` in their name which is the common rule for custom
 * elements.
 *
 * @stable
 */
export const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata;
/**
 * Defines a schema that will allow any property on any element.
 *
 * @experimental
 */
export const NO_ERRORS_SCHEMA: SchemaMetadata;
/**
 * Type of the NgModule decorator / constructor function.
 *
 * @stable
 */
export interface NgModuleDecorator {
    /**
     * Defines an NgModule.
     */
    (obj?: NgModule): TypeDecorator;
    new (obj?: NgModule): NgModule;
}
/**
 * Type of the NgModule metadata.
 *
 * @stable
 */
export interface NgModule {
    /**
     * Defines the set of injectable objects that are available in the injector
     * of this module.
     *
     * ## Simple Example
     *
     * Here is an example of a class that can be injected:
     *
     * ```
     * class Greeter {
     *    greet(name:string) {
     *      return 'Hello ' + name + '!';
     *    }
     * }
     *
     * @NgModule({
     *   providers: [
     *     Greeter
     *   ]
     * })
     * class HelloWorld {
     *   greeter:Greeter;
     *
     *   constructor(greeter:Greeter) {
     *     this.greeter = greeter;
     *   }
     * }
     * ```
     */
    providers?: Provider[];
    /**
     * Specifies a list of directives/pipes that belong to this module.
     *
     * ### Example
     *
     * ```javascript
     * @NgModule({
     *   declarations: [NgFor]
     * })
     * class CommonModule {
     * }
     * ```
     */
    declarations?: Array<Type<any> | any[]>;
    /**
     * Specifies a list of modules whose exported directives/pipes
     * should be available to templates in this module.
     * This can also contain {@link ModuleWithProviders}.
     *
     * ### Example
     *
     * ```javascript
     * @NgModule({
     *   imports: [CommonModule]
     * })
     * class MainModule {
     * }
     * ```
     */
    imports?: Array<Type<any> | ModuleWithProviders | any[]>;
    /**
     * Specifies a list of directives/pipes/modules that can be used within the template
     * of any component that is part of an Angular module
     * that imports this Angular module.
     *
     * ### Example
     *
     * ```javascript
     * @NgModule({
     *   exports: [NgFor]
     * })
     * class CommonModule {
     * }
     * ```
     */
    exports?: Array<Type<any> | any[]>;
    /**
     * Specifies a list of components that should be compiled when this module is defined.
     * For each component listed here, Angular will create a {@link ComponentFactory}
     * and store it in the {@link ComponentFactoryResolver}.
     */
    entryComponents?: Array<Type<any> | any[]>;
    /**
     * Defines the components that should be bootstrapped when
     * this module is bootstrapped. The components listed here
     * will automatically be added to `entryComponents`.
     */
    bootstrap?: Array<Type<any> | any[]>;
    /**
     * Elements and properties that are not Angular components nor directives have to be declared in
     * the schema.
     *
     * Available schemas:
     * - `NO_ERRORS_SCHEMA`: any elements and properties are allowed,
     * - `CUSTOM_ELEMENTS_SCHEMA`: any custom elements (tag name has "-") with any properties are
     *   allowed.
     *
     * @security When using one of `NO_ERRORS_SCHEMA` or `CUSTOM_ELEMENTS_SCHEMA` we're trusting that
     * allowed elements (and its properties) securely escape inputs.
     */
    schemas?: Array<SchemaMetadata | any[]>;
    /**
     * An opaque ID for this module, e.g. a name or a path. Used to identify modules in
     * `getModuleFactory`. If left `undefined`, the `NgModule` will not be registered with
     * `getModuleFactory`.
     */
    id?: string;
}
/**
 * NgModule decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const NgModule: NgModuleDecorator;
}
declare module '@angular/core/src/metadata/ng_module' {
export * from '~@angular/core/src/metadata/ng_module';
}

// Generated by typings
// Source: node_modules/@angular/core/src/metadata/view.d.ts
declare module '~@angular/core/src/metadata/view' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Defines template and style encapsulation options available for Component's {@link Component}.
 *
 * See {@link Component#encapsulation}.
 * @stable
 */
export enum ViewEncapsulation {
    /**
     * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
     * Element and pre-processing the style rules provided via
     * {@link Component#styles} or {@link Component#styleUrls}, and adding the new Host Element
     * attribute to all selectors.
     *
     * This is the default option.
     */
    Emulated = 0,
    /**
     * Use the native encapsulation mechanism of the renderer.
     *
     * For the DOM this means using [Shadow DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
     * creating a ShadowRoot for Component's Host Element.
     */
    Native = 1,
    /**
     * Don't provide any template or style encapsulation.
     */
    None = 2,
}
/**
 * Metadata properties available for configuring Views.
 *
 * For details on the `@Component` annotation, see {@link Component}.
 *
 * ### Example
 *
 * ```
 * @Component({
 *   selector: 'greet',
 *   template: 'Hello {{name}}!',
 * })
 * class Greet {
 *   name: string;
 *
 *   constructor() {
 *     this.name = 'World';
 *   }
 * }
 * ```
 *
 * @deprecated Use Component instead.
 *
 * {@link Component}
 */
export class ViewMetadata {
    /** {@link Component#templateUrl} */
    templateUrl: string | undefined;
    /** {@link Component#template} */
    template: string | undefined;
    /** {@link Component#stylesUrl} */
    styleUrls: string[] | undefined;
    /** {@link Component#styles} */
    styles: string[] | undefined;
    /** {@link Component#encapsulation} */
    encapsulation: ViewEncapsulation | undefined;
    /** {@link Component#animation} */
    animations: any[] | undefined;
    /** {@link Component#interpolation} */
    interpolation: [string, string] | undefined;
    constructor({templateUrl, template, encapsulation, styles, styleUrls, animations, interpolation}?: {
        templateUrl?: string;
        template?: string;
        encapsulation?: ViewEncapsulation;
        styles?: string[];
        styleUrls?: string[];
        animations?: any[];
        interpolation?: [string, string];
    });
}
}
declare module '@angular/core/src/metadata/view' {
export * from '~@angular/core/src/metadata/view';
}

// Generated by typings
// Source: node_modules/@angular/core/src/metadata.d.ts
declare module '~@angular/core/src/metadata' {
export { ANALYZE_FOR_ENTRY_COMPONENTS, Attribute, ContentChild, ContentChildDecorator, ContentChildren, ContentChildrenDecorator, Query, ViewChild, ViewChildDecorator, ViewChildren, ViewChildrenDecorator } from '~@angular/core/src/metadata/di';
export { Component, ComponentDecorator, Directive, DirectiveDecorator, HostBinding, HostListener, Input, Output, Pipe } from '~@angular/core/src/metadata/directives';
export { AfterContentChecked, AfterContentInit, AfterViewChecked, AfterViewInit, DoCheck, OnChanges, OnDestroy, OnInit } from '~@angular/core/src/metadata/lifecycle_hooks';
export { CUSTOM_ELEMENTS_SCHEMA, ModuleWithProviders, NO_ERRORS_SCHEMA, NgModule, SchemaMetadata } from '~@angular/core/src/metadata/ng_module';
export { ViewEncapsulation } from '~@angular/core/src/metadata/view';
}
declare module '@angular/core/src/metadata' {
export * from '~@angular/core/src/metadata';
}

// Generated by typings
// Source: node_modules/@angular/core/src/version.d.ts
declare module '~@angular/core/src/version' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @whatItDoes Represents the version of Angular
 *
 * @stable
 */
export class Version {
    full: string;
    constructor(full: string);
    readonly major: string;
    readonly minor: string;
    readonly patch: string;
}
/**
 * @stable
 */
export const VERSION: Version;
}
declare module '@angular/core/src/version' {
export * from '~@angular/core/src/version';
}

// Generated by typings
// Source: node_modules/@angular/core/src/zone.d.ts
declare module '~@angular/core/src/zone' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { NgZone } from '~@angular/core/src/zone/ng_zone';
}
declare module '@angular/core/src/zone' {
export * from '~@angular/core/src/zone';
}

// Generated by typings
// Source: node_modules/@angular/core/src/render.d.ts
declare module '~@angular/core/src/render' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { RenderComponentType, Renderer, Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2, RootRenderer } from '~@angular/core/src/render/api';
}
declare module '@angular/core/src/render' {
export * from '~@angular/core/src/render';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/ng_module_factory_loader.d.ts
declare module '~@angular/core/src/linker/ng_module_factory_loader' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NgModuleFactory } from '~@angular/core/src/linker/ng_module_factory';
/**
 * Used to load ng module factories.
 * @stable
 */
export abstract class NgModuleFactoryLoader {
    abstract load(path: string): Promise<NgModuleFactory<any>>;
}
/**
 * Registers a loaded module. Should only be called from generated NgModuleFactory code.
 * @experimental
 */
export function registerModuleFactory(id: string, factory: NgModuleFactory<any>): void;
export function clearModulesForTest(): void;
/**
 * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
 * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
 * cannot be found.
 * @experimental
 */
export function getModuleFactory(id: string): NgModuleFactory<any>;
}
declare module '@angular/core/src/linker/ng_module_factory_loader' {
export * from '~@angular/core/src/linker/ng_module_factory_loader';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/system_js_ng_module_factory_loader.d.ts
declare module '~@angular/core/src/linker/system_js_ng_module_factory_loader' {
import { Compiler } from '~@angular/core/src/linker/compiler';
import { NgModuleFactory } from '~@angular/core/src/linker/ng_module_factory';
import { NgModuleFactoryLoader } from '~@angular/core/src/linker/ng_module_factory_loader';
/**
 * Configuration for SystemJsNgModuleLoader.
 * token.
 *
 * @experimental
 */
export abstract class SystemJsNgModuleLoaderConfig {
    /**
     * Prefix to add when computing the name of the factory module for a given module name.
     */
    factoryPathPrefix: string;
    /**
     * Suffix to add when computing the name of the factory module for a given module name.
     */
    factoryPathSuffix: string;
}
/**
 * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
 * @experimental
 */
export class SystemJsNgModuleLoader implements NgModuleFactoryLoader {
    private _compiler;
    private _config;
    constructor(_compiler: Compiler, config?: SystemJsNgModuleLoaderConfig);
    load(path: string): Promise<NgModuleFactory<any>>;
    private loadAndCompile(path);
    private loadFactory(path);
}
}
declare module '@angular/core/src/linker/system_js_ng_module_factory_loader' {
export * from '~@angular/core/src/linker/system_js_ng_module_factory_loader';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker.d.ts
declare module '~@angular/core/src/linker' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { COMPILER_OPTIONS, Compiler, CompilerFactory, CompilerOptions, ModuleWithComponentFactories } from '~@angular/core/src/linker/compiler';
export { ComponentFactory, ComponentRef } from '~@angular/core/src/linker/component_factory';
export { ComponentFactoryResolver } from '~@angular/core/src/linker/component_factory_resolver';
export { ElementRef } from '~@angular/core/src/linker/element_ref';
export { NgModuleFactory, NgModuleRef } from '~@angular/core/src/linker/ng_module_factory';
export { NgModuleFactoryLoader, getModuleFactory } from '~@angular/core/src/linker/ng_module_factory_loader';
export { QueryList } from '~@angular/core/src/linker/query_list';
export { SystemJsNgModuleLoader, SystemJsNgModuleLoaderConfig } from '~@angular/core/src/linker/system_js_ng_module_factory_loader';
export { TemplateRef } from '~@angular/core/src/linker/template_ref';
export { ViewContainerRef } from '~@angular/core/src/linker/view_container_ref';
export { EmbeddedViewRef, ViewRef } from '~@angular/core/src/linker/view_ref';
}
declare module '@angular/core/src/linker' {
export * from '~@angular/core/src/linker';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/element.d.ts
declare module '~@angular/core/src/view/element' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { RendererType2 } from '~@angular/core/src/render/api';
import { SecurityContext } from '~@angular/core/src/security';
import { BindingFlags, ElementData, ElementHandleEventFn, NodeDef, NodeFlags, QueryValueType, ViewData, ViewDefinitionFactory } from '~@angular/core/src/view/types';
export function anchorDef(flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][], ngContentIndex: number, childCount: number, handleEvent?: ElementHandleEventFn, templateFactory?: ViewDefinitionFactory): NodeDef;
export function elementDef(flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][], ngContentIndex: number, childCount: number, namespaceAndName: string, fixedAttrs?: [string, string][], bindings?: [BindingFlags, string, string | SecurityContext][], outputs?: ([string, string])[], handleEvent?: ElementHandleEventFn, componentView?: ViewDefinitionFactory, componentRendererType?: RendererType2 | null): NodeDef;
export function createElement(view: ViewData, renderHost: any, def: NodeDef): ElementData;
export function listenToElementOutputs(view: ViewData, compView: ViewData, def: NodeDef, el: any): void;
export function checkAndUpdateElementInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
export function checkAndUpdateElementDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;
}
declare module '@angular/core/src/view/element' {
export * from '~@angular/core/src/view/element';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/ng_content.d.ts
declare module '~@angular/core/src/view/ng_content' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NodeDef, ViewData } from '~@angular/core/src/view/types';
export function ngContentDef(ngContentIndex: number, index: number): NodeDef;
export function appendNgContent(view: ViewData, renderHost: any, def: NodeDef): void;
}
declare module '@angular/core/src/view/ng_content' {
export * from '~@angular/core/src/view/ng_content';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/pure_expression.d.ts
declare module '~@angular/core/src/view/pure_expression' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NodeDef, PureExpressionData, ViewData } from '~@angular/core/src/view/types';
export function purePipeDef(argCount: number): NodeDef;
export function pureArrayDef(argCount: number): NodeDef;
export function pureObjectDef(propertyNames: string[]): NodeDef;
export function createPureExpression(view: ViewData, def: NodeDef): PureExpressionData;
export function checkAndUpdatePureExpressionInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
export function checkAndUpdatePureExpressionDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;
}
declare module '@angular/core/src/view/pure_expression' {
export * from '~@angular/core/src/view/pure_expression';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/query.d.ts
declare module '~@angular/core/src/view/query' {
import { QueryList } from '~@angular/core/src/linker/query_list';
import { NodeDef, NodeFlags, QueryBindingType, QueryValueType, ViewData } from '~@angular/core/src/view/types';
export function queryDef(flags: NodeFlags, id: number, bindings: {
    [propName: string]: QueryBindingType;
}): NodeDef;
export function createQuery(): QueryList<any>;
export function dirtyParentQueries(view: ViewData): void;
export function checkAndUpdateQuery(view: ViewData, nodeDef: NodeDef): void;
export function getQueryValue(view: ViewData, nodeDef: NodeDef, queryValueType: QueryValueType): any;
}
declare module '@angular/core/src/view/query' {
export * from '~@angular/core/src/view/query';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/refs.d.ts
declare module '~@angular/core/src/view/refs' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ApplicationRef } from '~@angular/core/src/application_ref';
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detection';
import { Injector } from '~@angular/core/src/di';
import { ComponentFactory } from '~@angular/core/src/linker/component_factory';
import { ViewContainerRef } from '~@angular/core/src/linker/view_container_ref';
import { EmbeddedViewRef, InternalViewRef } from '~@angular/core/src/linker/view_ref';
import { Renderer as RendererV1 } from '~@angular/core/src/render/api';
import { Type } from '~@angular/core/src/type';
import { ElementData, NodeDef, TemplateData, ViewContainerData, ViewData, ViewDefinitionFactory } from '~@angular/core/src/view/types';
export function createComponentFactory(selector: string, componentType: Type<any>, viewDefFactory: ViewDefinitionFactory, inputs: {
    [propName: string]: string;
} | null, outputs: {
    [propName: string]: string;
}, ngContentSelectors: string[]): ComponentFactory<any>;
export function getComponentViewDefinitionFactory(componentFactory: ComponentFactory<any>): ViewDefinitionFactory;
export function createViewContainerData(view: ViewData, elDef: NodeDef, elData: ElementData): ViewContainerData;
export function createChangeDetectorRef(view: ViewData): ChangeDetectorRef;
export class ViewRef_ implements EmbeddedViewRef<any>, InternalViewRef {
    private _viewContainerRef;
    private _appRef;
    constructor(_view: ViewData);
    readonly rootNodes: any[];
    readonly context: any;
    readonly destroyed: boolean;
    markForCheck(): void;
    detach(): void;
    detectChanges(): void;
    checkNoChanges(): void;
    reattach(): void;
    onDestroy(callback: Function): void;
    destroy(): void;
    detachFromAppRef(): void;
    attachToAppRef(appRef: ApplicationRef): void;
    attachToViewContainerRef(vcRef: ViewContainerRef): void;
}
export function createTemplateData(view: ViewData, def: NodeDef): TemplateData;
export function createInjector(view: ViewData, elDef: NodeDef): Injector;
export function nodeValue(view: ViewData, index: number): any;
export function createRendererV1(view: ViewData): RendererV1;
}
declare module '@angular/core/src/view/refs' {
export * from '~@angular/core/src/view/refs';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/services.d.ts
declare module '~@angular/core/src/view/services' {
import { DebugContext } from '~@angular/core/src/view/types';
export function initServicesIfNeeded(): void;
export function getCurrentDebugContext(): DebugContext | null;
}
declare module '@angular/core/src/view/services' {
export * from '~@angular/core/src/view/services';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/text.d.ts
declare module '~@angular/core/src/view/text' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { NodeDef, TextData, ViewData } from '~@angular/core/src/view/types';
export function textDef(ngContentIndex: number, constants: string[]): NodeDef;
export function createText(view: ViewData, renderHost: any, def: NodeDef): TextData;
export function checkAndUpdateTextInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
export function checkAndUpdateTextDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;
}
declare module '@angular/core/src/view/text' {
export * from '~@angular/core/src/view/text';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/util.d.ts
declare module '~@angular/core/src/view/util' {
import { ViewEncapsulation } from '~@angular/core/src/metadata/view';
import { RendererType2 } from '~@angular/core/src/render/api';
import { BindingDef, BindingFlags, ElementData, NodeDef, QueryValueType, ViewData, ViewDefinition, ViewDefinitionFactory } from '~@angular/core/src/view/types';
export const NOOP: any;
export function tokenKey(token: any): string;
export function unwrapValue(view: ViewData, nodeIdx: number, bindingIdx: number, value: any): any;
export function createRendererType2(values: {
    styles: (string | any[])[];
    encapsulation: ViewEncapsulation;
    data: {
        [kind: string]: any[];
    };
}): RendererType2;
export function resolveRendererType2(type?: RendererType2 | null): RendererType2 | null;
export function checkBinding(view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean;
export function checkAndUpdateBinding(view: ViewData, def: NodeDef, bindingIdx: number, value: any): boolean;
export function checkBindingNoChanges(view: ViewData, def: NodeDef, bindingIdx: number, value: any): void;
export function markParentViewsForCheck(view: ViewData): void;
export function markParentViewsForCheckProjectedViews(view: ViewData, endView: ViewData): void;
export function dispatchEvent(view: ViewData, nodeIndex: number, eventName: string, event: any): boolean;
export function declaredViewContainer(view: ViewData): ElementData | null;
/**
 * for component views, this is the host element.
 * for embedded views, this is the index of the parent node
 * that contains the view container.
 */
export function viewParentEl(view: ViewData): NodeDef | null;
export function renderNode(view: ViewData, def: NodeDef): any;
export function elementEventFullName(target: string | null, name: string): string;
export function isComponentView(view: ViewData): boolean;
export function isEmbeddedView(view: ViewData): boolean;
export function filterQueryId(queryId: number): number;
export function splitMatchedQueriesDsl(matchedQueriesDsl: [string | number, QueryValueType][] | null): {
    matchedQueries: {
        [queryId: string]: QueryValueType;
    };
    references: {
        [refId: string]: QueryValueType;
    };
    matchedQueryIds: number;
};
export function getParentRenderElement(view: ViewData, renderHost: any, def: NodeDef): any;
export function resolveViewDefinition(factory: ViewDefinitionFactory): ViewDefinition;
export function rootRenderNodes(view: ViewData): any[];
export const enum RenderNodeAction {
    Collect = 0,
    AppendChild = 1,
    InsertBefore = 2,
    RemoveChild = 3,
}
export function visitRootRenderNodes(view: ViewData, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void;
export function visitSiblingRenderNodes(view: ViewData, action: RenderNodeAction, startIndex: number, endIndex: number, parentNode: any, nextSibling: any, target?: any[]): void;
export function visitProjectedRenderNodes(view: ViewData, ngContentIndex: number, action: RenderNodeAction, parentNode: any, nextSibling: any, target?: any[]): void;
export function splitNamespace(name: string): string[];
export function calcBindingFlags(bindings: BindingDef[]): BindingFlags;
export function interpolate(valueCount: number, constAndInterp: string[]): string;
export function inlineInterpolate(valueCount: number, c0: string, a1: any, c1: string, a2?: any, c2?: string, a3?: any, c3?: string, a4?: any, c4?: string, a5?: any, c5?: string, a6?: any, c6?: string, a7?: any, c7?: string, a8?: any, c8?: string, a9?: any, c9?: string): string;
export const EMPTY_ARRAY: any[];
export const EMPTY_MAP: {
    [key: string]: any;
};
}
declare module '@angular/core/src/view/util' {
export * from '~@angular/core/src/view/util';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/view.d.ts
declare module '~@angular/core/src/view/view' {
import { ArgumentType, NodeDef, RootData, ViewData, ViewDefinition, ViewFlags, ViewUpdateFn } from '~@angular/core/src/view/types';
export function viewDef(flags: ViewFlags, nodes: NodeDef[], updateDirectives?: ViewUpdateFn, updateRenderer?: ViewUpdateFn): ViewDefinition;
export function createEmbeddedView(parent: ViewData, anchorDef: NodeDef, context?: any): ViewData;
export function createRootView(root: RootData, def: ViewDefinition, context?: any): ViewData;
export function checkNoChangesView(view: ViewData): void;
export function checkAndUpdateView(view: ViewData): void;
export function checkAndUpdateNode(view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): boolean;
export function checkNoChangesNode(view: ViewData, nodeDef: NodeDef, argStyle: ArgumentType, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any;
export function destroyView(view: ViewData): void;
}
declare module '@angular/core/src/view/view' {
export * from '~@angular/core/src/view/view';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/view_attach.d.ts
declare module '~@angular/core/src/view/view_attach' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ElementData, ViewData } from '~@angular/core/src/view/types';
export function attachEmbeddedView(parentView: ViewData, elementData: ElementData, viewIndex: number | undefined | null, view: ViewData): void;
export function detachEmbeddedView(elementData: ElementData, viewIndex?: number): ViewData | null;
export function detachProjectedView(view: ViewData): void;
export function moveEmbeddedView(elementData: ElementData, oldViewIndex: number, newViewIndex: number): ViewData;
export function renderDetachView(view: ViewData): void;
}
declare module '@angular/core/src/view/view_attach' {
export * from '~@angular/core/src/view/view_attach';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/index.d.ts
declare module '~@angular/core/src/view/index' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { anchorDef, elementDef } from '~@angular/core/src/view/element';
export { ngContentDef } from '~@angular/core/src/view/ng_content';
export { directiveDef, pipeDef, providerDef } from '~@angular/core/src/view/provider';
export { pureArrayDef, pureObjectDef, purePipeDef } from '~@angular/core/src/view/pure_expression';
export { queryDef } from '~@angular/core/src/view/query';
export { ViewRef_, createComponentFactory, getComponentViewDefinitionFactory, nodeValue } from '~@angular/core/src/view/refs';
export { initServicesIfNeeded } from '~@angular/core/src/view/services';
export { textDef } from '~@angular/core/src/view/text';
export { EMPTY_ARRAY, EMPTY_MAP, createRendererType2, elementEventFullName, inlineInterpolate, interpolate, rootRenderNodes, unwrapValue } from '~@angular/core/src/view/util';
export { viewDef } from '~@angular/core/src/view/view';
export { attachEmbeddedView, detachEmbeddedView, moveEmbeddedView } from '~@angular/core/src/view/view_attach';
export * from '~@angular/core/src/view/types';
}
declare module '@angular/core/src/view/index' {
export * from '~@angular/core/src/view/index';
}

// Generated by typings
// Source: node_modules/@angular/core/src/debug/debug_node.d.ts
declare module '~@angular/core/src/debug/debug_node' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injector } from '~@angular/core/src/di';
import { DebugContext } from '~@angular/core/src/view/index';
export class EventListener {
    name: string;
    callback: Function;
    constructor(name: string, callback: Function);
}
/**
 * @experimental All debugging apis are currently experimental.
 */
export class DebugNode {
    private _debugContext;
    nativeNode: any;
    listeners: EventListener[];
    parent: DebugElement | null;
    constructor(nativeNode: any, parent: DebugNode | null, _debugContext: DebugContext);
    readonly injector: Injector;
    readonly componentInstance: any;
    readonly context: any;
    readonly references: {
        [key: string]: any;
    };
    readonly providerTokens: any[];
    /**
     * @deprecated since v4
     */
    readonly source: string;
}
/**
 * @experimental All debugging apis are currently experimental.
 */
export class DebugElement extends DebugNode {
    name: string;
    properties: {
        [key: string]: any;
    };
    attributes: {
        [key: string]: string | null;
    };
    classes: {
        [key: string]: boolean;
    };
    styles: {
        [key: string]: string | null;
    };
    childNodes: DebugNode[];
    nativeElement: any;
    constructor(nativeNode: any, parent: any, _debugContext: DebugContext);
    addChild(child: DebugNode): void;
    removeChild(child: DebugNode): void;
    insertChildrenAfter(child: DebugNode, newChildren: DebugNode[]): void;
    insertBefore(refChild: DebugNode, newChild: DebugNode): void;
    query(predicate: Predicate<DebugElement>): DebugElement;
    queryAll(predicate: Predicate<DebugElement>): DebugElement[];
    queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[];
    readonly children: DebugElement[];
    triggerEventHandler(eventName: string, eventObj: any): void;
}
/**
 * @experimental
 */
export function asNativeElements(debugEls: DebugElement[]): any;
/**
 * @experimental
 */
export function getDebugNode(nativeNode: any): DebugNode | null;
export function getAllDebugNodes(): DebugNode[];
export function indexDebugNode(node: DebugNode): void;
export function removeDebugNodeFromIndex(node: DebugNode): void;
/**
 * A boolean-valued function over a value, possibly including context information
 * regarding that value's position in an array.
 *
 * @experimental All debugging apis are currently experimental.
 */
export interface Predicate<T> {
    (value: T): boolean;
}
}
declare module '@angular/core/src/debug/debug_node' {
export * from '~@angular/core/src/debug/debug_node';
}

// Generated by typings
// Source: node_modules/@angular/core/src/testability/testability.d.ts
declare module '~@angular/core/src/testability/testability' {
import { NgZone } from '~@angular/core/src/zone/ng_zone';
/**
 * Testability API.
 * `declare` keyword causes tsickle to generate externs, so these methods are
 * not renamed by Closure Compiler.
 * @experimental
 */
export interface PublicTestability {
    isStable(): boolean;
    whenStable(callback: Function): void;
    findProviders(using: any, provider: string, exactMatch: boolean): any[];
}
/**
 * The Testability service provides testing hooks that can be accessed from
 * the browser and by services such as Protractor. Each bootstrapped Angular
 * application on the page will have an instance of Testability.
 * @experimental
 */
export class Testability implements PublicTestability {
    private _ngZone;
    constructor(_ngZone: NgZone);
    increasePendingRequestCount(): number;
    decreasePendingRequestCount(): number;
    isStable(): boolean;
    whenStable(callback: Function): void;
    getPendingRequestCount(): number;
    /** @deprecated use findProviders */
    findBindings(using: any, provider: string, exactMatch: boolean): any[];
    findProviders(using: any, provider: string, exactMatch: boolean): any[];
}
/**
 * A global registry of {@link Testability} instances for specific elements.
 * @experimental
 */
export class TestabilityRegistry {
    constructor();
    registerApplication(token: any, testability: Testability): void;
    getTestability(elem: any): Testability | null;
    getAllTestabilities(): Testability[];
    getAllRootElements(): any[];
    findTestabilityInTree(elem: Node, findInAncestors?: boolean): Testability | null;
}
/**
 * Adapter interface for retrieving the `Testability` service associated for a
 * particular context.
 *
 * @experimental Testability apis are primarily intended to be used by e2e test tool vendors like
 * the Protractor team.
 */
export interface GetTestability {
    addToWindow(registry: TestabilityRegistry): void;
    findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null;
}
/**
 * Set the {@link GetTestability} implementation used by the Angular testing framework.
 * @experimental
 */
export function setTestabilityGetter(getter: GetTestability): void;
}
declare module '@angular/core/src/testability/testability' {
export * from '~@angular/core/src/testability/testability';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection.d.ts
declare module '~@angular/core/src/change_detection' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Change detection enables data binding in Angular.
 */
export { ChangeDetectionStrategy, ChangeDetectorRef, CollectionChangeRecord, DefaultIterableDiffer, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers, NgIterable, PipeTransform, SimpleChange, SimpleChanges, TrackByFn, TrackByFunction, WrappedValue } from '~@angular/core/src/change_detection/change_detection';
}
declare module '@angular/core/src/change_detection' {
export * from '~@angular/core/src/change_detection';
}

// Generated by typings
// Source: node_modules/@angular/core/src/platform_core_providers.d.ts
declare module '~@angular/core/src/platform_core_providers' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { PlatformRef } from '~@angular/core/src/application_ref';
import { Provider } from '~@angular/core/src/di';
/**
 * This platform has to be included in any other platform
 *
 * @experimental
 */
export const platformCore: (extraProviders?: Provider[] | undefined) => PlatformRef;
}
declare module '@angular/core/src/platform_core_providers' {
export * from '~@angular/core/src/platform_core_providers';
}

// Generated by typings
// Source: node_modules/@angular/core/src/i18n/tokens.d.ts
declare module '~@angular/core/src/i18n/tokens' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { InjectionToken } from '~@angular/core/src/di/injection_token';
/**
 * @experimental i18n support is experimental.
 */
export const LOCALE_ID: InjectionToken<string>;
/**
 * @experimental i18n support is experimental.
 */
export const TRANSLATIONS: InjectionToken<string>;
/**
 * @experimental i18n support is experimental.
 */
export const TRANSLATIONS_FORMAT: InjectionToken<string>;
/**
 * @experimental i18n support is experimental.
 */
export enum MissingTranslationStrategy {
    Error = 0,
    Warning = 1,
    Ignore = 2,
}
}
declare module '@angular/core/src/i18n/tokens' {
export * from '~@angular/core/src/i18n/tokens';
}

// Generated by typings
// Source: node_modules/@angular/core/src/event_emitter.d.ts
declare module '~@angular/core/src/event_emitter' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Subject } from 'rxjs/Subject';
/**
 * Use by directives and components to emit custom Events.
 *
 * ### Examples
 *
 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
 * title gets clicked:
 *
 * ```
 * @Component({
 *   selector: 'zippy',
 *   template: `
 *   <div class="zippy">
 *     <div (click)="toggle()">Toggle</div>
 *     <div [hidden]="!visible">
 *       <ng-content></ng-content>
 *     </div>
 *  </div>`})
 * export class Zippy {
 *   visible: boolean = true;
 *   @Output() open: EventEmitter<any> = new EventEmitter();
 *   @Output() close: EventEmitter<any> = new EventEmitter();
 *
 *   toggle() {
 *     this.visible = !this.visible;
 *     if (this.visible) {
 *       this.open.emit(null);
 *     } else {
 *       this.close.emit(null);
 *     }
 *   }
 * }
 * ```
 *
 * The events payload can be accessed by the parameter `$event` on the components output event
 * handler:
 *
 * ```
 * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
 * ```
 *
 * Uses Rx.Observable but provides an adapter to make it work as specified here:
 * https://github.com/jhusain/observable-spec
 *
 * Once a reference implementation of the spec is available, switch to it.
 * @stable
 */
export class EventEmitter<T> extends Subject<T> {
    __isAsync: boolean;
    /**
     * Creates an instance of {@link EventEmitter}, which depending on `isAsync`,
     * delivers events synchronously or asynchronously.
     *
     * @param isAsync By default, events are delivered synchronously (default value: `false`).
     * Set to `true` for asynchronous event delivery.
     */
    constructor(isAsync?: boolean);
    emit(value?: T): void;
    subscribe(generatorOrNext?: any, error?: any, complete?: any): any;
}
}
declare module '@angular/core/src/event_emitter' {
export * from '~@angular/core/src/event_emitter';
}

// Generated by typings
// Source: node_modules/@angular/core/src/errors.d.ts
declare module '~@angular/core/src/errors' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { DebugContext } from '~@angular/core/src/view/index';
export const ERROR_TYPE = "ngType";
export const ERROR_COMPONENT_TYPE = "ngComponentType";
export const ERROR_DEBUG_CONTEXT = "ngDebugContext";
export const ERROR_ORIGINAL_ERROR = "ngOriginalError";
export const ERROR_LOGGER = "ngErrorLogger";
export function getType(error: Error): Function;
export function getDebugContext(error: Error): DebugContext;
export function getOriginalError(error: Error): Error;
export function getErrorLogger(error: Error): (console: Console, ...values: any[]) => void;
}
declare module '@angular/core/src/errors' {
export * from '~@angular/core/src/errors';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/reflector.d.ts
declare module '~@angular/core/src/reflection/reflector' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '~@angular/core/src/type';
import { PlatformReflectionCapabilities } from '~@angular/core/src/reflection/platform_reflection_capabilities';
import { ReflectorReader } from '~@angular/core/src/reflection/reflector_reader';
import { GetterFn, MethodFn, SetterFn } from '~@angular/core/src/reflection/types';
export { PlatformReflectionCapabilities } from '~@angular/core/src/reflection/platform_reflection_capabilities';
export { GetterFn, MethodFn, SetterFn } from '~@angular/core/src/reflection/types';
/**
 * Provides access to reflection data about symbols. Used internally by Angular
 * to power dependency injection and compilation.
 */
export class Reflector extends ReflectorReader {
    reflectionCapabilities: PlatformReflectionCapabilities;
    constructor(reflectionCapabilities: PlatformReflectionCapabilities);
    updateCapabilities(caps: PlatformReflectionCapabilities): void;
    factory(type: Type<any>): Function;
    parameters(typeOrFunc: Type<any>): any[][];
    annotations(typeOrFunc: Type<any>): any[];
    propMetadata(typeOrFunc: Type<any>): {
        [key: string]: any[];
    };
    hasLifecycleHook(type: any, lcProperty: string): boolean;
    getter(name: string): GetterFn;
    setter(name: string): SetterFn;
    method(name: string): MethodFn;
    importUri(type: any): string;
    resourceUri(type: any): string;
    resolveIdentifier(name: string, moduleUrl: string, members: string[] | null, runtime: any): any;
    resolveEnum(identifier: any, name: string): any;
}
}
declare module '@angular/core/src/reflection/reflector' {
export * from '~@angular/core/src/reflection/reflector';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/reflection.d.ts
declare module '~@angular/core/src/reflection/reflection' {
import { Reflector } from '~@angular/core/src/reflection/reflector';
export { Reflector } from '~@angular/core/src/reflection/reflector';
/**
 * The {@link Reflector} used internally in Angular to access metadata
 * about symbols.
 */
export const reflector: Reflector;
}
declare module '@angular/core/src/reflection/reflection' {
export * from '~@angular/core/src/reflection/reflection';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/reflection_capabilities.d.ts
declare module '~@angular/core/src/reflection/reflection_capabilities' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '~@angular/core/src/type';
import { PlatformReflectionCapabilities } from '~@angular/core/src/reflection/platform_reflection_capabilities';
import { GetterFn, MethodFn, SetterFn } from '~@angular/core/src/reflection/types';
/**
 * Attention: This regex has to hold even if the code is minified!
 */
export const DELEGATE_CTOR: RegExp;
export class ReflectionCapabilities implements PlatformReflectionCapabilities {
    private _reflect;
    constructor(reflect?: any);
    isReflectionEnabled(): boolean;
    factory<T>(t: Type<T>): (args: any[]) => T;
    private _ownParameters(type, parentCtor);
    parameters(type: Type<any>): any[][];
    private _ownAnnotations(typeOrFunc, parentCtor);
    annotations(typeOrFunc: Type<any>): any[];
    private _ownPropMetadata(typeOrFunc, parentCtor);
    propMetadata(typeOrFunc: any): {
        [key: string]: any[];
    };
    hasLifecycleHook(type: any, lcProperty: string): boolean;
    getter(name: string): GetterFn;
    setter(name: string): SetterFn;
    method(name: string): MethodFn;
    importUri(type: any): string;
    resourceUri(type: any): string;
    resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;
    resolveEnum(enumIdentifier: any, name: string): any;
}
}
declare module '@angular/core/src/reflection/reflection_capabilities' {
export * from '~@angular/core/src/reflection/reflection_capabilities';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/reflector_reader.d.ts
declare module '~@angular/core/src/reflection/reflector_reader' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Provides read-only access to reflection data about symbols. Used internally by Angular
 * to power dependency injection and compilation.
 */
export abstract class ReflectorReader {
    abstract parameters(typeOrFunc: any): any[][];
    abstract annotations(typeOrFunc: any): any[];
    abstract propMetadata(typeOrFunc: any): {
        [key: string]: any[];
    };
    abstract importUri(typeOrFunc: any): string | null;
    abstract resourceUri(typeOrFunc: any): string;
    abstract resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any;
    abstract resolveEnum(identifier: any, name: string): any;
}
}
declare module '@angular/core/src/reflection/reflector_reader' {
export * from '~@angular/core/src/reflection/reflector_reader';
}

// Generated by typings
// Source: node_modules/@angular/core/src/util.d.ts
declare module '~@angular/core/src/util' {
const _global: {
    [name: string]: any;
};
export { _global as global };
export function getSymbolIterator(): string | symbol;
export function scheduleMicroTask(fn: Function): void;
export function looseIdentical(a: any, b: any): boolean;
export function stringify(token: any): string;
}
declare module '@angular/core/src/util' {
export * from '~@angular/core/src/util';
}

// Generated by typings
// Source: node_modules/@angular/core/src/util/lang.d.ts
declare module '~@angular/core/src/util/lang' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Observable } from 'rxjs/Observable';
/**
 * Determine if the argument is shaped like a Promise
 */
export function isPromise(obj: any): obj is Promise<any>;
/**
 * Determine if the argument is an Observable
 */
export function isObservable(obj: any | Observable<any>): obj is Observable<any>;
}
declare module '@angular/core/src/util/lang' {
export * from '~@angular/core/src/util/lang';
}

// Generated by typings
// Source: node_modules/@angular/core/src/core_private_export.d.ts
declare module '~@angular/core/src/core_private_export' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { ALLOW_MULTIPLE_PLATFORMS as ɵALLOW_MULTIPLE_PLATFORMS } from '~@angular/core/src/application_ref';
export { APP_ID_RANDOM_PROVIDER as ɵAPP_ID_RANDOM_PROVIDER } from '~@angular/core/src/application_tokens';
export { ValueUnwrapper as ɵValueUnwrapper, devModeEqual as ɵdevModeEqual } from '~@angular/core/src/change_detection/change_detection_util';
export { isListLikeIterable as ɵisListLikeIterable } from '~@angular/core/src/change_detection/change_detection_util';
export { ChangeDetectorStatus as ɵChangeDetectorStatus, isDefaultChangeDetectionStrategy as ɵisDefaultChangeDetectionStrategy } from '~@angular/core/src/change_detection/constants';
export { Console as ɵConsole } from '~@angular/core/src/console';
export { ERROR_COMPONENT_TYPE as ɵERROR_COMPONENT_TYPE } from '~@angular/core/src/errors';
export { ComponentFactory as ɵComponentFactory } from '~@angular/core/src/linker/component_factory';
export { CodegenComponentFactoryResolver as ɵCodegenComponentFactoryResolver } from '~@angular/core/src/linker/component_factory_resolver';
export { LIFECYCLE_HOOKS_VALUES as ɵLIFECYCLE_HOOKS_VALUES, LifecycleHooks as ɵLifecycleHooks } from '~@angular/core/src/metadata/lifecycle_hooks';
export { ViewMetadata as ɵViewMetadata } from '~@angular/core/src/metadata/view';
export { Reflector as ɵReflector, reflector as ɵreflector } from '~@angular/core/src/reflection/reflection';
export { ReflectionCapabilities as ɵReflectionCapabilities } from '~@angular/core/src/reflection/reflection_capabilities';
export { ReflectorReader as ɵReflectorReader } from '~@angular/core/src/reflection/reflector_reader';
export { GetterFn as ɵGetterFn, MethodFn as ɵMethodFn, SetterFn as ɵSetterFn } from '~@angular/core/src/reflection/types';
export { DirectRenderer as ɵDirectRenderer, RenderDebugInfo as ɵRenderDebugInfo } from '~@angular/core/src/render/api';
export { global as ɵglobal, looseIdentical as ɵlooseIdentical, stringify as ɵstringify } from '~@angular/core/src/util';
export { makeDecorator as ɵmakeDecorator } from '~@angular/core/src/util/decorators';
export { isObservable as ɵisObservable, isPromise as ɵisPromise } from '~@angular/core/src/util/lang';
export { NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR as ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR } from '~@angular/core/src/view/provider';
}
declare module '@angular/core/src/core_private_export' {
export * from '~@angular/core/src/core_private_export';
}

// Generated by typings
// Source: node_modules/@angular/core/src/security.d.ts
declare module '~@angular/core/src/security' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property
 * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly
 * handled.
 *
 * See DomSanitizer for more details on security in Angular applications.
 *
 * @stable
 */
export enum SecurityContext {
    NONE = 0,
    HTML = 1,
    STYLE = 2,
    SCRIPT = 3,
    URL = 4,
    RESOURCE_URL = 5,
}
/**
 * Sanitizer is used by the views to sanitize potentially dangerous values.
 *
 * @stable
 */
export abstract class Sanitizer {
    abstract sanitize(context: SecurityContext, value: {} | string | null): string | null;
}
}
declare module '@angular/core/src/security' {
export * from '~@angular/core/src/security';
}

// Generated by typings
// Source: node_modules/@angular/core/src/codegen_private_exports.d.ts
declare module '~@angular/core/src/codegen_private_exports' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export { CodegenComponentFactoryResolver as ɵCodegenComponentFactoryResolver } from '~@angular/core/src/linker/component_factory_resolver';
export { NgModuleInjector as ɵNgModuleInjector } from '~@angular/core/src/linker/ng_module_factory';
export { registerModuleFactory as ɵregisterModuleFactory } from '~@angular/core/src/linker/ng_module_factory_loader';
export { reflector as ɵreflector } from '~@angular/core/src/reflection/reflection';
export { ArgumentType as ɵArgumentType, BindingFlags as ɵBindingFlags, DepFlags as ɵDepFlags, EMPTY_ARRAY as ɵEMPTY_ARRAY, EMPTY_MAP as ɵEMPTY_MAP, NodeFlags as ɵNodeFlags, QueryBindingType as ɵQueryBindingType, QueryValueType as ɵQueryValueType, ViewDefinition as ɵViewDefinition, ViewFlags as ɵViewFlags, anchorDef as ɵand, createComponentFactory as ɵccf, createRendererType2 as ɵcrt, directiveDef as ɵdid, elementDef as ɵeld, elementEventFullName as ɵelementEventFullName, getComponentViewDefinitionFactory as ɵgetComponentViewDefinitionFactory, inlineInterpolate as ɵinlineInterpolate, interpolate as ɵinterpolate, ngContentDef as ɵncd, nodeValue as ɵnov, pipeDef as ɵpid, providerDef as ɵprd, pureArrayDef as ɵpad, pureObjectDef as ɵpod, purePipeDef as ɵppd, queryDef as ɵqud, textDef as ɵted, unwrapValue as ɵunv, viewDef as ɵvid } from '~@angular/core/src/view/index';
}
declare module '@angular/core/src/codegen_private_exports' {
export * from '~@angular/core/src/codegen_private_exports';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/animation_metadata_wrapped.d.ts
declare module '~@angular/core/src/animation/animation_metadata_wrapped' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { AnimateTimings, AnimationMetadataType } from '~@angular/core/src/animation/dsl';
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export const AUTO_STYLE = "*";
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export interface AnimationMetadata {
    type: AnimationMetadataType;
}
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export interface AnimationTriggerMetadata {
    name: string;
    definitions: AnimationMetadata[];
}
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export interface AnimationStateMetadata extends AnimationMetadata {
    name: string;
    styles: AnimationStyleMetadata;
}
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export interface AnimationTransitionMetadata extends AnimationMetadata {
    expr: string | ((fromState: string, toState: string) => boolean);
    animation: AnimationMetadata | AnimationMetadata[];
}
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export interface AnimationKeyframesSequenceMetadata extends AnimationMetadata {
    steps: AnimationStyleMetadata[];
}
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export interface AnimationStyleMetadata extends AnimationMetadata {
    styles: {
        [key: string]: string | number;
    } | {
        [key: string]: string | number;
    }[];
    offset?: number;
}
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export interface AnimationAnimateMetadata extends AnimationMetadata {
    timings: string | number | AnimateTimings;
    styles: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata | null;
}
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export interface AnimationSequenceMetadata extends AnimationMetadata {
    steps: AnimationMetadata[];
}
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export interface AnimationGroupMetadata extends AnimationMetadata {
    steps: AnimationMetadata[];
}
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export function trigger(name: string, definitions: AnimationMetadata[]): AnimationTriggerMetadata;
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export function animate(timings: string | number, styles?: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata): AnimationAnimateMetadata;
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export function group(steps: AnimationMetadata[]): AnimationGroupMetadata;
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export function sequence(steps: AnimationMetadata[]): AnimationSequenceMetadata;
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export function style(tokens: {
    [key: string]: string | number;
} | Array<{
    [key: string]: string | number;
}>): AnimationStyleMetadata;
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export function state(name: string, styles: AnimationStyleMetadata): AnimationStateMetadata;
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export function keyframes(steps: AnimationStyleMetadata[]): AnimationKeyframesSequenceMetadata;
/**
 * @deprecated This symbol has moved. Please Import from @angular/animations instead!
 */
export function transition(stateChangeExpr: string | ((fromState: string, toState: string) => boolean), steps: AnimationMetadata | AnimationMetadata[]): AnimationTransitionMetadata;
/**
 * @deprecated This has been renamed to `AnimationEvent`. Please import it from @angular/animations.
 */
export interface AnimationTransitionEvent {
    fromState: string;
    toState: string;
    totalTime: number;
    phaseName: string;
    element: any;
    triggerName: string;
}
}
declare module '@angular/core/src/animation/animation_metadata_wrapped' {
export * from '~@angular/core/src/animation/animation_metadata_wrapped';
}

// Generated by typings
// Source: node_modules/@angular/core/src/core.d.ts
declare module '~@angular/core/src/core' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point from which you should import all public core APIs.
 */
export * from '~@angular/core/src/metadata';
export * from '~@angular/core/src/version';
export { Class, ClassDefinition, TypeDecorator } from '~@angular/core/src/util/decorators';
export * from '~@angular/core/src/di';
export { createPlatform, assertPlatform, destroyPlatform, getPlatform, PlatformRef, ApplicationRef, enableProdMode, isDevMode, createPlatformFactory, NgProbeToken } from '~@angular/core/src/application_ref';
export { APP_ID, PACKAGE_ROOT_URL, PLATFORM_INITIALIZER, PLATFORM_ID, APP_BOOTSTRAP_LISTENER } from '~@angular/core/src/application_tokens';
export { APP_INITIALIZER, ApplicationInitStatus } from '~@angular/core/src/application_init';
export * from '~@angular/core/src/zone';
export * from '~@angular/core/src/render';
export * from '~@angular/core/src/linker';
export { DebugElement, DebugNode, asNativeElements, getDebugNode, Predicate } from '~@angular/core/src/debug/debug_node';
export { GetTestability, Testability, TestabilityRegistry, setTestabilityGetter } from '~@angular/core/src/testability/testability';
export * from '~@angular/core/src/change_detection';
export * from '~@angular/core/src/platform_core_providers';
export { TRANSLATIONS, TRANSLATIONS_FORMAT, LOCALE_ID, MissingTranslationStrategy } from '~@angular/core/src/i18n/tokens';
export { ApplicationModule } from '~@angular/core/src/application_module';
export { wtfCreateScope, wtfLeave, wtfStartTimeRange, wtfEndTimeRange, WtfScopeFn } from '~@angular/core/src/profile/profile';
export { Type } from '~@angular/core/src/type';
export { EventEmitter } from '~@angular/core/src/event_emitter';
export { ErrorHandler } from '~@angular/core/src/error_handler';
export * from '~@angular/core/src/core_private_export';
export { Sanitizer, SecurityContext } from '~@angular/core/src/security';
export * from '~@angular/core/src/codegen_private_exports';
export * from '~@angular/core/src/animation/animation_metadata_wrapped';
/**
 * @deprecated from v4
 */
export type AnimationEntryMetadata = any;
/**
 * @deprecated from v4
 */
export type AnimationStateTransitionMetadata = any;
/**
 * @deprecated from v4
 */
export type AnimationPlayer = any;
/**
 * @deprecated from v4
 */
export type AnimationStyles = any;
/**
 * @deprecated from v4
 */
export type AnimationKeyframe = any;
}
declare module '@angular/core/src/core' {
export * from '~@angular/core/src/core';
}

// Generated by typings
// Source: node_modules/@angular/core/public_api.d.ts
declare module '~@angular/core/public_api' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * Entry point for all public APIs of the core package.
 */
export * from '~@angular/core/src/core';
}
declare module '@angular/core/public_api' {
export * from '~@angular/core/public_api';
}

// Generated by typings
// Source: node_modules/@angular/core/src/animation/dsl.d.ts
declare module '~@angular/core/src/animation/dsl' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export interface ɵStyleData {
    [key: string]: string | number;
}
/**
 * @experimental Animation support is experimental.
 */
export type AnimateTimings = {
    duration: number;
    delay: number;
    easing: string | null;
};
/**
 * @experimental Animation support is experimental.
 */
export const enum AnimationMetadataType {
    State = 0,
    Transition = 1,
    Sequence = 2,
    Group = 3,
    Animate = 4,
    KeyframeSequence = 5,
    Style = 6,
}
/**
 * @experimental Animation support is experimental.
 */
export const AUTO_STYLE = "*";
/**
 * @experimental Animation support is experimental.
 */
export interface AnimationMetadata {
    type: AnimationMetadataType;
}
/**
 * @experimental Animation support is experimental.
 */
export interface AnimationTriggerMetadata {
    name: string;
    definitions: AnimationMetadata[];
}
/**
 * Metadata representing the entry of animations. Instances of this class are provided via the
 * animation DSL when the {@link state state animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export interface AnimationStateMetadata extends AnimationMetadata {
    name: string;
    styles: AnimationStyleMetadata;
}
/**
 * Metadata representing the entry of animations. Instances of this class are provided via the
 * animation DSL when the {@link transition transition animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export interface AnimationTransitionMetadata extends AnimationMetadata {
    expr: string | ((fromState: string, toState: string) => boolean);
    animation: AnimationMetadata | AnimationMetadata[];
}
/**
 * Metadata representing the entry of animations. Instances of this class are provided via the
 * animation DSL when the {@link keyframes keyframes animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export interface AnimationKeyframesSequenceMetadata extends AnimationMetadata {
    steps: AnimationStyleMetadata[];
}
/**
 * Metadata representing the entry of animations. Instances of this class are provided via the
 * animation DSL when the {@link style style animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export interface AnimationStyleMetadata extends AnimationMetadata {
    styles: {
        [key: string]: string | number;
    } | {
        [key: string]: string | number;
    }[];
    offset?: number;
}
/**
 * Metadata representing the entry of animations. Instances of this class are provided via the
 * animation DSL when the {@link animate animate animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export interface AnimationAnimateMetadata extends AnimationMetadata {
    timings: string | number | AnimateTimings;
    styles: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata | null;
}
/**
 * Metadata representing the entry of animations. Instances of this class are provided via the
 * animation DSL when the {@link sequence sequence animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export interface AnimationSequenceMetadata extends AnimationMetadata {
    steps: AnimationMetadata[];
}
/**
 * Metadata representing the entry of animations. Instances of this class are provided via the
 * animation DSL when the {@link group group animation function} is called.
 *
 * @experimental Animation support is experimental.
 */
export interface AnimationGroupMetadata extends AnimationMetadata {
    steps: AnimationMetadata[];
}
/**
 * `trigger` is an animation-specific function that is designed to be used inside of Angular's
 animation DSL language. If this information is new, please navigate to the {@link
 Component#animations component animations metadata page} to gain a better understanding of
 how animations in Angular are used.
 *
 * `trigger` Creates an animation trigger which will a list of {@link state state} and {@link
 transition transition} entries that will be evaluated when the expression bound to the trigger
 changes.
 *
 * Triggers are registered within the component annotation data under the {@link
 Component#animations animations section}. An animation trigger can be placed on an element
 within a template by referencing the name of the trigger followed by the expression value that the
 trigger is bound to (in the form of `[@triggerName]="expression"`.
 *
 * ### Usage
 *
 * `trigger` will create an animation trigger reference based on the provided `name` value. The
 provided `animation` value is expected to be an array consisting of {@link state state} and {@link
 transition transition} declarations.
 *
 * ```typescript
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'my-component-tpl.html',
 *   animations: [
 *     trigger("myAnimationTrigger", [
 *       state(...),
 *       state(...),
 *       transition(...),
 *       transition(...)
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "something";
 * }
 * ```
 *
 * The template associated with this component will make use of the `myAnimationTrigger` animation
 trigger by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 tools/gulp-tasks/validate-commit-message.js ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function trigger(name: string, definitions: AnimationMetadata[]): AnimationTriggerMetadata;
/**
 * `animate` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `animate` specifies an animation step that will apply the provided `styles` data for a given
 * amount of time based on the provided `timing` expression value. Calls to `animate` are expected
 * to be used within {@link sequence an animation sequence}, {@link group group}, or {@link
 * transition transition}.
 *
 * ### Usage
 *
 * The `animate` function accepts two input parameters: `timing` and `styles`:
 *
 * - `timing` is a string based value that can be a combination of a duration with optional delay
 * and easing values. The format for the expression breaks down to `duration delay easing`
 * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
 * delay=100, easing=ease-out`. If a numeric value is provided then that will be used as the
 * `duration` value in millisecond form.
 * - `styles` is the style input data which can either be a call to {@link style style} or {@link
 * keyframes keyframes}. If left empty then the styles from the destination state will be collected
 * and used (this is useful when describing an animation step that will complete an animation by
 * {@link transition#the-final-animate-call animating to the final state}).
 *
 * ```typescript
 * // various functions for specifying timing data
 * animate(500, style(...))
 * animate("1s", style(...))
 * animate("100ms 0.5s", style(...))
 * animate("5s ease", style(...))
 * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
 *
 * // either style() of keyframes() can be used
 * animate(500, style({ background: "red" }))
 * animate(500, keyframes([
 *   style({ background: "blue" })),
 *   style({ background: "red" }))
 * ])
 * ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function animate(timings: string | number, styles?: AnimationStyleMetadata | AnimationKeyframesSequenceMetadata | null): AnimationAnimateMetadata;
/**
 * `group` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `group` specifies a list of animation steps that are all run in parallel. Grouped animations are
 * useful when a series of styles must be animated/closed off at different statrting/ending times.
 *
 * The `group` function can either be used within a {@link sequence sequence} or a {@link transition
 * transition} and it will only continue to the next instruction once all of the inner animation
 * steps have completed.
 *
 * ### Usage
 *
 * The `steps` data that is passed into the `group` animation function can either consist of {@link
 * style style} or {@link animate animate} function calls. Each call to `style()` or `animate()`
 * within a group will be executed instantly (use {@link keyframes keyframes} or a {@link
 * animate#usage animate() with a delay value} to offset styles to be applied at a later time).
 *
 * ```typescript
 * group([
 *   animate("1s", { background: "black" }))
 *   animate("2s", { color: "white" }))
 * ])
 * ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function group(steps: AnimationMetadata[]): AnimationGroupMetadata;
/**
 * `sequence` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used by
 * default when an array is passed as animation data into {@link transition transition}.)
 *
 * The `sequence` function can either be used within a {@link group group} or a {@link transition
 * transition} and it will only continue to the next instruction once each of the inner animation
 * steps have completed.
 *
 * To perform animation styling in parallel with other animation steps then have a look at the
 * {@link group group} animation function.
 *
 * ### Usage
 *
 * The `steps` data that is passed into the `sequence` animation function can either consist of
 * {@link style style} or {@link animate animate} function calls. A call to `style()` will apply the
 * provided styling data immediately while a call to `animate()` will apply its styling data over a
 * given time depending on its timing data.
 *
 * ```typescript
 * sequence([
 *   style({ opacity: 0 })),
 *   animate("1s", { opacity: 1 }))
 * ])
 * ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function sequence(steps: AnimationMetadata[]): AnimationSequenceMetadata;
/**
 * `style` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `style` declares a key/value object containing CSS properties/styles that can then be used for
 * {@link state animation states}, within an {@link sequence animation sequence}, or as styling data
 * for both {@link animate animate} and {@link keyframes keyframes}.
 *
 * ### Usage
 *
 * `style` takes in a key/value string map as data and expects one or more CSS property/value pairs
 * to be defined.
 *
 * ```typescript
 * // string values are used for css properties
 * style({ background: "red", color: "blue" })
 *
 * // numerical (pixel) values are also supported
 * style({ width: 100, height: 0 })
 * ```
 *
 * #### Auto-styles (using `*`)
 *
 * When an asterix (`*`) character is used as a value then it will be detected from the element
 * being animated and applied as animation data when the animation starts.
 *
 * This feature proves useful for a state depending on layout and/or environment factors; in such
 * cases the styles are calculated just before the animation starts.
 *
 * ```typescript
 * // the steps below will animate from 0 to the
 * // actual height of the element
 * style({ height: 0 }),
 * animate("1s", style({ height: "*" }))
 * ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function style(tokens: {
    [key: string]: string | number;
} | Array<{
    [key: string]: string | number;
}>): AnimationStyleMetadata;
/**
 * `state` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `state` declares an animation state within the given trigger. When a state is active within a
 * component then its associated styles will persist on the element that the trigger is attached to
 * (even when the animation ends).
 *
 * To animate between states, have a look at the animation {@link transition transition} DSL
 * function. To register states to an animation trigger please have a look at the {@link trigger
 * trigger} function.
 *
 * #### The `void` state
 *
 * The `void` state value is a reserved word that angular uses to determine when the element is not
 * apart of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
 * associated element is void).
 *
 * #### The `*` (default) state
 *
 * The `*` state (when styled) is a fallback state that will be used if the state that is being
 * animated is not declared within the trigger.
 *
 * ### Usage
 *
 * `state` will declare an animation state with its associated styles
 * within the given trigger.
 *
 * - `stateNameExpr` can be one or more state names separated by commas.
 * - `styles` refers to the {@link style styling data} that will be persisted on the element once
 * the state has been reached.
 *
 * ```typescript
 * // "void" is a reserved name for a state and is used to represent
 * // the state in which an element is detached from from the application.
 * state("void", style({ height: 0 }))
 *
 * // user-defined states
 * state("closed", style({ height: 0 }))
 * state("open, visible", style({ height: "*" }))
 * ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function state(name: string, styles: AnimationStyleMetadata): AnimationStateMetadata;
/**
 * `keyframes` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `keyframes` specifies a collection of {@link style style} entries each optionally characterized
 * by an `offset` value.
 *
 * ### Usage
 *
 * The `keyframes` animation function is designed to be used alongside the {@link animate animate}
 * animation function. Instead of applying animations from where they are currently to their
 * destination, keyframes can describe how each style entry is applied and at what point within the
 * animation arc (much like CSS Keyframe Animations do).
 *
 * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at what
 * percentage of the animate time the styles will be applied.
 *
 * ```typescript
 * // the provided offset values describe when each backgroundColor value is applied.
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red", offset: 0 }),
 *   style({ backgroundColor: "blue", offset: 0.2 }),
 *   style({ backgroundColor: "orange", offset: 0.3 }),
 *   style({ backgroundColor: "black", offset: 1 })
 * ]))
 * ```
 *
 * Alternatively, if there are no `offset` values used within the style entries then the offsets
 * will be calculated automatically.
 *
 * ```typescript
 * animate("5s", keyframes([
 *   style({ backgroundColor: "red" }) // offset = 0
 *   style({ backgroundColor: "blue" }) // offset = 0.33
 *   style({ backgroundColor: "orange" }) // offset = 0.66
 *   style({ backgroundColor: "black" }) // offset = 1
 * ]))
 * ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function keyframes(steps: AnimationStyleMetadata[]): AnimationKeyframesSequenceMetadata;
/**
 * `transition` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `transition` declares the {@link sequence sequence of animation steps} that will be run when the
 * provided `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 =>
 * state2` which consists of two known states (use an asterix (`*`) to refer to a dynamic starting
 * and/or ending state).
 *
 * A function can also be provided as the `stateChangeExpr` argument for a transition and this
 * function will be executed each time a state change occurs. If the value returned within the
 * function is true then the associated animation will be run.
 *
 * Animation transitions are placed within an {@link trigger animation trigger}. For an transition
 * to animate to a state value and persist its styles then one or more {@link state animation
 * states} is expected to be defined.
 *
 * ### Usage
 *
 * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
 * what the previous state is and what the current state has become. In other words, if a transition
 * is defined that matches the old/current state criteria then the associated animation will be
 * triggered.
 *
 * ```typescript
 * // all transition/state changes are defined within an animation trigger
 * trigger("myAnimationTrigger", [
 *   // if a state is defined then its styles will be persisted when the
 *   // animation has fully completed itself
 *   state("on", style({ background: "green" })),
 *   state("off", style({ background: "grey" })),
 *
 *   // a transition animation that will be kicked off when the state value
 *   // bound to "myAnimationTrigger" changes from "on" to "off"
 *   transition("on => off", animate(500)),
 *
 *   // it is also possible to do run the same animation for both directions
 *   transition("on <=> off", animate(500)),
 *
 *   // or to define multiple states pairs separated by commas
 *   transition("on => off, off => void", animate(500)),
 *
 *   // this is a catch-all state change for when an element is inserted into
 *   // the page and the destination state is unknown
 *   transition("void => *", [
 *     style({ opacity: 0 }),
 *     animate(500)
 *   ]),
 *
 *   // this will capture a state change between any states
 *   transition("* => *", animate("1s 0s")),
 *
 *   // you can also go full out and include a function
 *   transition((fromState, toState) => {
 *     // when `true` then it will allow the animation below to be invoked
 *     return fromState == "off" && toState == "on";
 *   }, animate("1s 0s"))
 * ])
 * ```
 *
 * The template associated with this component will make use of the `myAnimationTrigger` animation
 * trigger by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * #### The final `animate` call
 *
 * If the final step within the transition steps is a call to `animate()` that **only** uses a
 * timing value with **no style data** then it will be automatically used as the final animation arc
 * for the element to animate itself to the final state. This involves an automatic mix of
 * adding/removing CSS styles so that the element will be in the exact state it should be for the
 * applied state to be presented correctly.
 *
 * ```
 * // start off by hiding the element, but make sure that it animates properly to whatever state
 * // is currently active for "myAnimationTrigger"
 * transition("void => *", [
 *   style({ opacity: 0 }),
 *   animate(500)
 * ])
 * ```
 *
 * ### Transition Aliases (`:enter` and `:leave`)
 *
 * Given that enter (insertion) and leave (removal) animations are so common, the `transition`
 * function accepts both `:enter` and `:leave` values which are aliases for the `void => *` and `*
 * => void` state changes.
 *
 * ```
 * transition(":enter", [
 *   style({ opacity: 0 }),
 *   animate(500, style({ opacity: 1 }))
 * ])
 * transition(":leave", [
 *   animate(500, style({ opacity: 0 }))
 * ])
 * ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
export function transition(stateChangeExpr: string | ((fromState: string, toState: string) => boolean), steps: AnimationMetadata | AnimationMetadata[]): AnimationTransitionMetadata;
}
declare module '@angular/core/src/animation/dsl' {
export * from '~@angular/core/src/animation/dsl';
}

// Generated by typings
// Source: node_modules/@angular/core/src/application_module.d.ts
declare module '~@angular/core/src/application_module' {
import { ApplicationRef } from '~@angular/core/src/application_ref';
import { IterableDiffers, KeyValueDiffers } from '~@angular/core/src/change_detection/change_detection';
export function _iterableDiffersFactory(): IterableDiffers;
export function _keyValueDiffersFactory(): KeyValueDiffers;
export function _localeFactory(locale?: string): string;
export function _initViewEngine(): void;
/**
 * This module includes the providers of @angular/core that are needed
 * to bootstrap components via `ApplicationRef`.
 *
 * @experimental
 */
export class ApplicationModule {
    constructor(appRef: ApplicationRef);
}
}
declare module '@angular/core/src/application_module' {
export * from '~@angular/core/src/application_module';
}

// Generated by typings
// Source: node_modules/@angular/core/src/error_handler.d.ts
declare module '~@angular/core/src/error_handler' {
/**
 * @whatItDoes Provides a hook for centralized exception handling.
 *
 * @description
 *
 * The default implementation of `ErrorHandler` prints error messages to the `console`. To
 * intercept error handling, write a custom exception handler that replaces this default as
 * appropriate for your app.
 *
 * ### Example
 *
 * ```
 * class MyErrorHandler implements ErrorHandler {
 *   handleError(error) {
 *     // do something with the exception
 *   }
 * }
 *
 * @NgModule({
 *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
 * })
 * class MyModule {}
 * ```
 *
 * @stable
 */
export class ErrorHandler {
    constructor(
        /**
         * @deprecated since v4.0 parameter no longer has an effect, as ErrorHandler will never
         * rethrow.
         */
        deprecatedParameter?: boolean);
    handleError(error: any): void;
}
export function wrappedError(message: string, originalError: any): Error;
}
declare module '@angular/core/src/error_handler' {
export * from '~@angular/core/src/error_handler';
}

// Generated by typings
// Source: node_modules/@angular/core/src/application_init.d.ts
declare module '~@angular/core/src/application_init' {
import { InjectionToken } from '~@angular/core/src/di';
/**
 * A function that will be executed when an application is initialized.
 * @experimental
 */
export const APP_INITIALIZER: InjectionToken<(() => void)[]>;
/**
 * A class that reflects the state of running {@link APP_INITIALIZER}s.
 *
 * @experimental
 */
export class ApplicationInitStatus {
    private appInits;
    private resolve;
    private reject;
    private initialized;
    private _donePromise;
    private _done;
    constructor(appInits: (() => any)[]);
    readonly done: boolean;
    readonly donePromise: Promise<any>;
}
}
declare module '@angular/core/src/application_init' {
export * from '~@angular/core/src/application_init';
}

// Generated by typings
// Source: node_modules/@angular/core/src/console.d.ts
declare module '~@angular/core/src/console' {
export class Console {
    log(message: string): void;
    warn(message: string): void;
}
}
declare module '@angular/core/src/console' {
export * from '~@angular/core/src/console';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/forward_ref.d.ts
declare module '~@angular/core/src/di/forward_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '~@angular/core/src/type';
/**
 * An interface that a function passed into {@link forwardRef} has to implement.
 *
 * ### Example
 *
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}
 * @experimental
 */
export interface ForwardRefFn {
    (): any;
}
/**
 * Allows to refer to references which are not yet defined.
 *
 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
 * DI is declared,
 * but not yet defined. It is also used when the `token` which we use when creating a query is not
 * yet defined.
 *
 * ### Example
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
 * @experimental
 */
export function forwardRef(forwardRefFn: ForwardRefFn): Type<any>;
/**
 * Lazily retrieves the reference value from a forwardRef.
 *
 * Acts as the identity function when given a non-forward-ref value.
 *
 * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
 *
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
 *
 * See: {@link forwardRef}
 * @experimental
 */
export function resolveForwardRef(type: any): any;
}
declare module '@angular/core/src/di/forward_ref' {
export * from '~@angular/core/src/di/forward_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/injection_token.d.ts
declare module '~@angular/core/src/di/injection_token' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Creates a token that can be used in a DI Provider.
 *
 * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))
 *
 * ```typescript
 * var t = new OpaqueToken("value");
 *
 * var injector = Injector.resolveAndCreate([
 *   {provide: t, useValue: "bindingValue"}
 * ]);
 *
 * expect(injector.get(t)).toEqual("bindingValue");
 * ```
 *
 * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions
 * caused by multiple providers using the same string as two different tokens.
 *
 * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better
 * error messages.
 * @deprecated since v4.0.0 because it does not support type information, use `InjectionToken<?>`
 * instead.
 */
export class OpaqueToken {
    protected _desc: string;
    constructor(_desc: string);
    toString(): string;
}
/**
 * Creates a token that can be used in a DI Provider.
 *
 * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a
 * runtime representation) such as when injecting an interface, callable type, array or
 * parametrized type.
 *
 * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by
 * the `Injector`. This provides additional level of type safety.
 *
 * ```
 * interface MyInterface {...}
 * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));
 * // myInterface is inferred to be MyInterface.
 * ```
 *
 * ### Example
 *
 * {@example core/di/ts/injector_spec.ts region='InjectionToken'}
 *
 * @stable
 */
export class InjectionToken<T> extends OpaqueToken {
    private _differentiate_from_OpaqueToken_structurally;
    constructor(desc: string);
    toString(): string;
}
}
declare module '@angular/core/src/di/injection_token' {
export * from '~@angular/core/src/di/injection_token';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di.d.ts
declare module '~@angular/core/src/di' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @module
 * @description
 * The `di` module provides dependency injection container services.
 */
export * from '~@angular/core/src/di/metadata';
export { forwardRef, resolveForwardRef, ForwardRefFn } from '~@angular/core/src/di/forward_ref';
export { Injector } from '~@angular/core/src/di/injector';
export { ReflectiveInjector } from '~@angular/core/src/di/reflective_injector';
export { Provider, TypeProvider, ValueProvider, ClassProvider, ExistingProvider, FactoryProvider } from '~@angular/core/src/di/provider';
export { ResolvedReflectiveFactory, ResolvedReflectiveProvider } from '~@angular/core/src/di/reflective_provider';
export { ReflectiveKey } from '~@angular/core/src/di/reflective_key';
export { InjectionToken, OpaqueToken } from '~@angular/core/src/di/injection_token';
}
declare module '@angular/core/src/di' {
export * from '~@angular/core/src/di';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/compiler.d.ts
declare module '~@angular/core/src/linker/compiler' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { InjectionToken } from '~@angular/core/src/di';
import { MissingTranslationStrategy } from '~@angular/core/src/i18n/tokens';
import { ViewEncapsulation } from '~@angular/core/src/metadata';
import { Type } from '~@angular/core/src/type';
import { ComponentFactory } from '~@angular/core/src/linker/component_factory';
import { NgModuleFactory } from '~@angular/core/src/linker/ng_module_factory';
/**
 * Combination of NgModuleFactory and ComponentFactorys.
 *
 * @experimental
 */
export class ModuleWithComponentFactories<T> {
    ngModuleFactory: NgModuleFactory<T>;
    componentFactories: ComponentFactory<any>[];
    constructor(ngModuleFactory: NgModuleFactory<T>, componentFactories: ComponentFactory<any>[]);
}
/**
 * Low-level service for running the angular compiler during runtime
 * to create {@link ComponentFactory}s, which
 * can later be used to create and render a Component instance.
 *
 * Each `@NgModule` provides an own `Compiler` to its injector,
 * that will use the directives/pipes of the ng module for compilation
 * of components.
 * @stable
 */
export class Compiler {
    /**
     * Compiles the given NgModule and all of its components. All templates of the components listed
     * in `entryComponents` have to be inlined.
     */
    compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;
    /**
     * Compiles the given NgModule and all of its components
     */
    compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;
    /**
     * Same as {@link #compileModuleSync} but also creates ComponentFactories for all components.
     */
    compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;
    /**
     * Same as {@link #compileModuleAsync} but also creates ComponentFactories for all components.
     */
    compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;
    /**
     * Exposes the CSS-style selectors that have been used in `ngContent` directives within
     * the template of the given component.
     * This is used by the `upgrade` library to compile the appropriate transclude content
     * in the AngularJS wrapper component.
     *
     * @deprecated since v4. Use ComponentFactory.ngContentSelectors instead.
     */
    getNgContentSelectors(component: Type<any>): string[];
    /**
     * Clears all caches.
     */
    clearCache(): void;
    /**
     * Clears the cache for the given component/ngModule.
     */
    clearCacheFor(type: Type<any>): void;
}
/**
 * Options for creating a compiler
 *
 * @experimental
 */
export type CompilerOptions = {
    /**
     * @deprecated since v4 this option has no effect anymore.
     */
    useDebug?: boolean;
    useJit?: boolean;
    defaultEncapsulation?: ViewEncapsulation;
    providers?: any[];
    missingTranslation?: MissingTranslationStrategy;
    enableLegacyTemplate?: boolean;
};
/**
 * Token to provide CompilerOptions in the platform injector.
 *
 * @experimental
 */
export const COMPILER_OPTIONS: InjectionToken<CompilerOptions[]>;
/**
 * A factory for creating a Compiler
 *
 * @experimental
 */
export abstract class CompilerFactory {
    abstract createCompiler(options?: CompilerOptions[]): Compiler;
}
}
declare module '@angular/core/src/linker/compiler' {
export * from '~@angular/core/src/linker/compiler';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/element_ref.d.ts
declare module '~@angular/core/src/linker/element_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A wrapper around a native element inside of a View.
 *
 * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
 * element.
 *
 * @security Permitting direct access to the DOM can make your application more vulnerable to
 * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
 * [Security Guide](http://g.co/ng/security).
 *
 * @stable
 */
export class ElementRef {
    /**
     * The underlying native element or `null` if direct access to native elements is not supported
     * (e.g. when the application runs in a web worker).
     *
     * <div class="callout is-critical">
     *   <header>Use with caution</header>
     *   <p>
     *    Use this API as the last resort when direct access to DOM is needed. Use templating and
     *    data-binding provided by Angular instead. Alternatively you take a look at {@link Renderer}
     *    which provides API that can safely be used even when direct access to native elements is not
     *    supported.
     *   </p>
     *   <p>
     *    Relying on direct DOM access creates tight coupling between your application and rendering
     *    layers which will make it impossible to separate the two and deploy your application into a
     *    web worker.
     *   </p>
     * </div>
     * @stable
     */
    nativeElement: any;
    constructor(nativeElement: any);
}
}
declare module '@angular/core/src/linker/element_ref' {
export * from '~@angular/core/src/linker/element_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/component_factory.d.ts
declare module '~@angular/core/src/linker/component_factory' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detection';
import { Injector } from '~@angular/core/src/di/injector';
import { Type } from '~@angular/core/src/type';
import { ElementRef } from '~@angular/core/src/linker/element_ref';
import { NgModuleRef } from '~@angular/core/src/linker/ng_module_factory';
import { ViewRef } from '~@angular/core/src/linker/view_ref';
/**
 * Represents an instance of a Component created via a {@link ComponentFactory}.
 *
 * `ComponentRef` provides access to the Component Instance as well other objects related to this
 * Component Instance and allows you to destroy the Component Instance via the {@link #destroy}
 * method.
 * @stable
 */
export abstract class ComponentRef<C> {
    /**
     * Location of the Host Element of this Component Instance.
     */
    readonly abstract location: ElementRef;
    /**
     * The injector on which the component instance exists.
     */
    readonly abstract injector: Injector;
    /**
     * The instance of the Component.
     */
    readonly abstract instance: C;
    /**
     * The {@link ViewRef} of the Host View of this Component instance.
     */
    readonly abstract hostView: ViewRef;
    /**
     * The {@link ChangeDetectorRef} of the Component instance.
     */
    readonly abstract changeDetectorRef: ChangeDetectorRef;
    /**
     * The component type.
     */
    readonly abstract componentType: Type<any>;
    /**
     * Destroys the component instance and all of the data structures associated with it.
     */
    abstract destroy(): void;
    /**
     * Allows to register a callback that will be called when the component is destroyed.
     */
    abstract onDestroy(callback: Function): void;
}
/**
 * @stable
 */
export abstract class ComponentFactory<C> {
    readonly abstract selector: string;
    readonly abstract componentType: Type<any>;
    /**
     * selector for all <ng-content> elements in the component.
     */
    readonly abstract ngContentSelectors: string[];
    /**
     * the inputs of the component.
     */
    readonly abstract inputs: {
        propName: string;
        templateName: string;
    }[];
    /**
     * the outputs of the component.
     */
    readonly abstract outputs: {
        propName: string;
        templateName: string;
    }[];
    /**
     * Creates a new component.
     */
    abstract create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, ngModule?: NgModuleRef<any>): ComponentRef<C>;
}
}
declare module '@angular/core/src/linker/component_factory' {
export * from '~@angular/core/src/linker/component_factory';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/component_factory_resolver.d.ts
declare module '~@angular/core/src/linker/component_factory_resolver' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injector } from '~@angular/core/src/di/injector';
import { Type } from '~@angular/core/src/type';
import { ComponentFactory, ComponentRef } from '~@angular/core/src/linker/component_factory';
import { NgModuleRef } from '~@angular/core/src/linker/ng_module_factory';
export function noComponentFactoryError(component: Function): Error;
export function getComponent(error: Error): Type<any>;
/**
 * @stable
 */
export abstract class ComponentFactoryResolver {
    static NULL: ComponentFactoryResolver;
    abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;
}
export class CodegenComponentFactoryResolver implements ComponentFactoryResolver {
    private _parent;
    private _ngModule;
    private _factories;
    constructor(factories: ComponentFactory<any>[], _parent: ComponentFactoryResolver, _ngModule: NgModuleRef<any>);
    resolveComponentFactory<T>(component: {
        new (...args: any[]): T;
    }): ComponentFactory<T>;
}
export class ComponentFactoryBoundToModule<C> extends ComponentFactory<C> {
    private factory;
    private ngModule;
    constructor(factory: ComponentFactory<C>, ngModule: NgModuleRef<any>);
    readonly selector: string;
    readonly componentType: Type<any>;
    readonly ngContentSelectors: string[];
    readonly inputs: {
        propName: string;
        templateName: string;
    }[];
    readonly outputs: {
        propName: string;
        templateName: string;
    }[];
    create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, ngModule?: NgModuleRef<any>): ComponentRef<C>;
}
}
declare module '@angular/core/src/linker/component_factory_resolver' {
export * from '~@angular/core/src/linker/component_factory_resolver';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/ng_module_factory.d.ts
declare module '~@angular/core/src/linker/ng_module_factory' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injector } from '~@angular/core/src/di/injector';
import { Type } from '~@angular/core/src/type';
import { ComponentFactory } from '~@angular/core/src/linker/component_factory';
import { ComponentFactoryResolver } from '~@angular/core/src/linker/component_factory_resolver';
/**
 * Represents an instance of an NgModule created via a {@link NgModuleFactory}.
 *
 * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
 * NgModule Instance.
 *
 * @stable
 */
export abstract class NgModuleRef<T> {
    /**
     * The injector that contains all of the providers of the NgModule.
     */
    readonly abstract injector: Injector;
    /**
     * The ComponentFactoryResolver to get hold of the ComponentFactories
     * declared in the `entryComponents` property of the module.
     */
    readonly abstract componentFactoryResolver: ComponentFactoryResolver;
    /**
     * The NgModule instance.
     */
    readonly abstract instance: T;
    /**
     * Destroys the module instance and all of the data structures associated with it.
     */
    abstract destroy(): void;
    /**
     * Allows to register a callback that will be called when the module is destroyed.
     */
    abstract onDestroy(callback: () => void): void;
}
/**
 * @experimental
 */
export class NgModuleFactory<T> {
    private _injectorClass;
    private _moduleType;
    constructor(_injectorClass: {
        new (parentInjector: Injector): NgModuleInjector<T>;
    }, _moduleType: Type<T>);
    readonly moduleType: Type<T>;
    create(parentInjector: Injector | null): NgModuleRef<T>;
}
export abstract class NgModuleInjector<T> implements Injector, NgModuleRef<T> {
    parent: Injector;
    bootstrapFactories: ComponentFactory<any>[];
    instance: T;
    private _destroyListeners;
    private _destroyed;
    private _cmpFactoryResolver;
    constructor(parent: Injector, factories: ComponentFactory<any>[], bootstrapFactories: ComponentFactory<any>[]);
    create(): void;
    abstract createInternal(): T;
    get(token: any, notFoundValue?: any): any;
    abstract getInternal(token: any, notFoundValue: any): any;
    readonly injector: Injector;
    readonly componentFactoryResolver: ComponentFactoryResolver;
    destroy(): void;
    onDestroy(callback: () => void): void;
    abstract destroyInternal(): void;
}
}
declare module '@angular/core/src/linker/ng_module_factory' {
export * from '~@angular/core/src/linker/ng_module_factory';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/view_ref.d.ts
declare module '~@angular/core/src/linker/view_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ApplicationRef } from '~@angular/core/src/application_ref';
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detector_ref';
/**
 * @stable
 */
export abstract class ViewRef extends ChangeDetectorRef {
    /**
     * Destroys the view and all of the data structures associated with it.
     */
    abstract destroy(): void;
    readonly abstract destroyed: boolean;
    abstract onDestroy(callback: Function): any;
}
/**
 * Represents an Angular View.
 *
 * <!-- TODO: move the next two paragraphs to the dev guide -->
 * A View is a fundamental building block of the application UI. It is the smallest grouping of
 * Elements which are created and destroyed together.
 *
 * Properties of elements in a View can change, but the structure (number and order) of elements in
 * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
 * removing nested Views via a {@link ViewContainerRef}. Each View can contain many View Containers.
 * <!-- /TODO -->
 *
 * ### Example
 *
 * Given this template...
 *
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <li *ngFor="let  item of items">{{item}}</li>
 * </ul>
 * ```
 *
 * We have two {@link TemplateRef}s:
 *
 * Outer {@link TemplateRef}:
 * ```
 * Count: {{items.length}}
 * <ul>
 *   <ng-template ngFor let-item [ngForOf]="items"></ng-template>
 * </ul>
 * ```
 *
 * Inner {@link TemplateRef}:
 * ```
 *   <li>{{item}}</li>
 * ```
 *
 * Notice that the original template is broken down into two separate {@link TemplateRef}s.
 *
 * The outer/inner {@link TemplateRef}s are then assembled into views like so:
 *
 * ```
 * <!-- ViewRef: outer-0 -->
 * Count: 2
 * <ul>
 *   <ng-template view-container-ref></ng-template>
 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
 * </ul>
 * <!-- /ViewRef: outer-0 -->
 * ```
 * @experimental
 */
export abstract class EmbeddedViewRef<C> extends ViewRef {
    readonly abstract context: C;
    readonly abstract rootNodes: any[];
}
export interface InternalViewRef extends ViewRef {
    detachFromAppRef(): void;
    attachToAppRef(appRef: ApplicationRef): void;
}
}
declare module '@angular/core/src/linker/view_ref' {
export * from '~@angular/core/src/linker/view_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/type.d.ts
declare module '~@angular/core/src/type' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @whatItDoes Represents a type that a Component or other object is instances of.
 *
 * @description
 *
 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
 * the `MyCustomComponent` constructor function.
 *
 * @stable
 */
export const Type: FunctionConstructor;
export function isType(v: any): v is Type<any>;
export interface Type<T> extends Function {
    new (...args: any[]): T;
}
}
declare module '@angular/core/src/type' {
export * from '~@angular/core/src/type';
}

// Generated by typings
// Source: node_modules/@angular/core/src/zone/ng_zone.d.ts
declare module '~@angular/core/src/zone/ng_zone' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { EventEmitter } from '~@angular/core/src/event_emitter';
/**
 * An injectable service for executing work inside or outside of the Angular zone.
 *
 * The most common use of this service is to optimize performance when starting a work consisting of
 * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
 * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
 * can reenter the Angular zone via {@link #run}.
 *
 * <!-- TODO: add/fix links to:
 *   - docs explaining zones and the use of zones in Angular and change-detection
 *   - link to runOutsideAngular/run (throughout this file!)
 *   -->
 *
 * ### Example
 *
 * ```
 * import {Component, NgZone} from '@angular/core';
 * import {NgIf} from '@angular/common';
 *
 * @Component({
 *   selector: 'ng-zone-demo'.
 *   template: `
 *     <h2>Demo: NgZone</h2>
 *
 *     <p>Progress: {{progress}}%</p>
 *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
 *
 *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
 *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
 *   `,
 * })
 * export class NgZoneDemo {
 *   progress: number = 0;
 *   label: string;
 *
 *   constructor(private _ngZone: NgZone) {}
 *
 *   // Loop inside the Angular zone
 *   // so the UI DOES refresh after each setTimeout cycle
 *   processWithinAngularZone() {
 *     this.label = 'inside';
 *     this.progress = 0;
 *     this._increaseProgress(() => console.log('Inside Done!'));
 *   }
 *
 *   // Loop outside of the Angular zone
 *   // so the UI DOES NOT refresh after each setTimeout cycle
 *   processOutsideOfAngularZone() {
 *     this.label = 'outside';
 *     this.progress = 0;
 *     this._ngZone.runOutsideAngular(() => {
 *       this._increaseProgress(() => {
 *       // reenter the Angular zone and display done
 *       this._ngZone.run(() => {console.log('Outside Done!') });
 *     }}));
 *   }
 *
 *   _increaseProgress(doneCallback: () => void) {
 *     this.progress += 1;
 *     console.log(`Current progress: ${this.progress}%`);
 *
 *     if (this.progress < 100) {
 *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
 *     } else {
 *       doneCallback();
 *     }
 *   }
 * }
 * ```
 *
 * @experimental
 */
export class NgZone {
    private outer;
    private inner;
    private _hasPendingMicrotasks;
    private _hasPendingMacrotasks;
    private _isStable;
    private _nesting;
    private _onUnstable;
    private _onMicrotaskEmpty;
    private _onStable;
    private _onErrorEvents;
    constructor({enableLongStackTrace}: {
        enableLongStackTrace?: boolean;
    });
    static isInAngularZone(): boolean;
    static assertInAngularZone(): void;
    static assertNotInAngularZone(): void;
    /**
     * Executes the `fn` function synchronously within the Angular zone and returns value returned by
     * the function.
     *
     * Running functions via `run` allows you to reenter Angular zone from a task that was executed
     * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * within the Angular zone.
     *
     * If a synchronous error happens it will be rethrown and not reported via `onError`.
     */
    run(fn: () => any): any;
    /**
     * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
     * rethrown.
     */
    runGuarded(fn: () => any): any;
    /**
     * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
     * the function.
     *
     * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
     * work that
     * doesn't trigger Angular change-detection or is subject to Angular's error handling.
     *
     * Any future tasks or microtasks scheduled from within this function will continue executing from
     * outside of the Angular zone.
     *
     * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
     */
    runOutsideAngular(fn: () => any): any;
    /**
     * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
     */
    readonly onUnstable: EventEmitter<any>;
    /**
     * Notifies when there is no more microtasks enqueue in the current VM Turn.
     * This is a hint for Angular to do change detection, which may enqueue more microtasks.
     * For this reason this event can fire multiple times per VM Turn.
     */
    readonly onMicrotaskEmpty: EventEmitter<any>;
    /**
     * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
     * implies we are about to relinquish VM turn.
     * This event gets called just once.
     */
    readonly onStable: EventEmitter<any>;
    /**
     * Notify that an error has been delivered.
     */
    readonly onError: EventEmitter<any>;
    /**
     * Whether there are no outstanding microtasks or macrotasks.
     */
    readonly isStable: boolean;
    readonly hasPendingMicrotasks: boolean;
    readonly hasPendingMacrotasks: boolean;
    private checkStable();
    private forkInnerZoneWithAngularBehavior();
    private onEnter();
    private onLeave();
    private setHasMicrotask(hasMicrotasks);
    private setHasMacrotask(hasMacrotasks);
    private triggerError(error);
}
}
declare module '@angular/core/src/zone/ng_zone' {
export * from '~@angular/core/src/zone/ng_zone';
}

// Generated by typings
// Source: node_modules/@angular/core/src/application_ref.d.ts
declare module '~@angular/core/src/application_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Observable } from 'rxjs/Observable';
import { ErrorHandler } from '~@angular/core/src/error_handler';
import { ApplicationInitStatus } from '~@angular/core/src/application_init';
import { Console } from '~@angular/core/src/console';
import { InjectionToken, Injector, Provider } from '~@angular/core/src/di';
import { CompilerOptions } from '~@angular/core/src/linker/compiler';
import { ComponentFactory, ComponentRef } from '~@angular/core/src/linker/component_factory';
import { ComponentFactoryResolver } from '~@angular/core/src/linker/component_factory_resolver';
import { NgModuleFactory, NgModuleRef } from '~@angular/core/src/linker/ng_module_factory';
import { ViewRef } from '~@angular/core/src/linker/view_ref';
import { Type } from '~@angular/core/src/type';
import { NgZone } from '~@angular/core/src/zone/ng_zone';
export const ALLOW_MULTIPLE_PLATFORMS: InjectionToken<boolean>;
/**
 * Disable Angular's development mode, which turns off assertions and other
 * checks within the framework.
 *
 * One important assertion this disables verifies that a change detection pass
 * does not result in additional changes to any bindings (also known as
 * unidirectional data flow).
 *
 * @stable
 */
export function enableProdMode(): void;
/**
 * Returns whether Angular is in development mode. After called once,
 * the value is locked and won't change any more.
 *
 * By default, this is true, unless a user calls `enableProdMode` before calling this.
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function isDevMode(): boolean;
/**
 * A token for third-party components that can register themselves with NgProbe.
 *
 * @experimental
 */
export class NgProbeToken {
    name: string;
    token: any;
    constructor(name: string, token: any);
}
/**
 * Creates a platform.
 * Platforms have to be eagerly created via this function.
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function createPlatform(injector: Injector): PlatformRef;
/**
 * Creates a factory for a platform
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function createPlatformFactory(parentPlatformFactory: ((extraProviders?: Provider[]) => PlatformRef) | null, name: string, providers?: Provider[]): (extraProviders?: Provider[]) => PlatformRef;
/**
 * Checks that there currently is a platform which contains the given token as a provider.
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function assertPlatform(requiredToken: any): PlatformRef;
/**
 * Destroy the existing platform.
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function destroyPlatform(): void;
/**
 * Returns the current platform.
 *
 * @experimental APIs related to application bootstrap are currently under review.
 */
export function getPlatform(): PlatformRef | null;
/**
 * The Angular platform is the entry point for Angular on a web page. Each page
 * has exactly one platform, and services (such as reflection) which are common
 * to every Angular application running on the page are bound in its scope.
 *
 * A page's platform is initialized implicitly when a platform is created via a platform factory
 * (e.g. {@link platformBrowser}), or explicitly by calling the {@link createPlatform} function.
 *
 * @stable
 */
export abstract class PlatformRef {
    /**
     * Creates an instance of an `@NgModule` for the given platform
     * for offline compilation.
     *
     * ## Simple Example
     *
     * ```typescript
     * my_module.ts:
     *
     * @NgModule({
     *   imports: [BrowserModule]
     * })
     * class MyModule {}
     *
     * main.ts:
     * import {MyModuleNgFactory} from './my_module.ngfactory';
     * import {platformBrowser} from '@angular/platform-browser';
     *
     * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
     * ```
     *
     * @experimental APIs related to application bootstrap are currently under review.
     */
    abstract bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>): Promise<NgModuleRef<M>>;
    /**
     * Creates an instance of an `@NgModule` for a given platform using the given runtime compiler.
     *
     * ## Simple Example
     *
     * ```typescript
     * @NgModule({
     *   imports: [BrowserModule]
     * })
     * class MyModule {}
     *
     * let moduleRef = platformBrowser().bootstrapModule(MyModule);
     * ```
     * @stable
     */
    abstract bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: CompilerOptions | CompilerOptions[]): Promise<NgModuleRef<M>>;
    /**
     * Register a listener to be called when the platform is disposed.
     */
    abstract onDestroy(callback: () => void): void;
    /**
     * Retrieve the platform {@link Injector}, which is the parent injector for
     * every Angular application on the page and provides singleton providers.
     */
    readonly abstract injector: Injector;
    /**
     * Destroy the Angular platform and all Angular applications on the page.
     */
    abstract destroy(): void;
    readonly abstract destroyed: boolean;
}
/**
 * workaround https://github.com/angular/tsickle/issues/350
 * @suppress {checkTypes}
 */
export class PlatformRef_ extends PlatformRef {
    private _injector;
    private _modules;
    private _destroyListeners;
    private _destroyed;
    constructor(_injector: Injector);
    onDestroy(callback: () => void): void;
    readonly injector: Injector;
    readonly destroyed: boolean;
    destroy(): void;
    bootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>): Promise<NgModuleRef<M>>;
    private _bootstrapModuleFactoryWithZone<M>(moduleFactory, ngZone?);
    bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: CompilerOptions | CompilerOptions[]): Promise<NgModuleRef<M>>;
    private _bootstrapModuleWithZone<M>(moduleType, compilerOptions?, ngZone?);
    private _moduleDoBootstrap(moduleRef);
}
/**
 * A reference to an Angular application running on a page.
 *
 * @stable
 */
export abstract class ApplicationRef {
    /**
     * Bootstrap a new component at the root level of the application.
     *
     * ### Bootstrap process
     *
     * When bootstrapping a new root component into an application, Angular mounts the
     * specified application component onto DOM elements identified by the [componentType]'s
     * selector and kicks off automatic change detection to finish initializing the component.
     *
     * ### Example
     * {@example core/ts/platform/platform.ts region='longform'}
     */
    abstract bootstrap<C>(componentFactory: ComponentFactory<C> | Type<C>): ComponentRef<C>;
    /**
     * Invoke this method to explicitly process change detection and its side-effects.
     *
     * In development mode, `tick()` also performs a second change detection cycle to ensure that no
     * further changes are detected. If additional changes are picked up during this second cycle,
     * bindings in the app have side-effects that cannot be resolved in a single change detection
     * pass.
     * In this case, Angular throws an error, since an Angular application can only have one change
     * detection pass during which all change detection must complete.
     */
    abstract tick(): void;
    /**
     * Get a list of component types registered to this application.
     * This list is populated even before the component is created.
     */
    readonly abstract componentTypes: Type<any>[];
    /**
     * Get a list of components registered to this application.
     */
    readonly abstract components: ComponentRef<any>[];
    /**
     * Attaches a view so that it will be dirty checked.
     * The view will be automatically detached when it is destroyed.
     * This will throw if the view is already attached to a ViewContainer.
     */
    abstract attachView(view: ViewRef): void;
    /**
     * Detaches a view from dirty checking again.
     */
    abstract detachView(view: ViewRef): void;
    /**
     * Returns the number of attached views.
     */
    readonly abstract viewCount: number;
    /**
     * Returns an Observable that indicates when the application is stable or unstable.
     */
    readonly abstract isStable: Observable<boolean>;
}
/**
 * workaround https://github.com/angular/tsickle/issues/350
 * @suppress {checkTypes}
 */
export class ApplicationRef_ extends ApplicationRef {
    private _zone;
    private _console;
    private _injector;
    private _exceptionHandler;
    private _componentFactoryResolver;
    private _initStatus;
    private _bootstrapListeners;
    private _rootComponents;
    private _rootComponentTypes;
    private _views;
    private _runningTick;
    private _enforceNoNewChanges;
    private _isStable;
    private _stable;
    constructor(_zone: NgZone, _console: Console, _injector: Injector, _exceptionHandler: ErrorHandler, _componentFactoryResolver: ComponentFactoryResolver, _initStatus: ApplicationInitStatus);
    attachView(viewRef: ViewRef): void;
    detachView(viewRef: ViewRef): void;
    bootstrap<C>(componentOrFactory: ComponentFactory<C> | Type<C>): ComponentRef<C>;
    private _loadComponent(componentRef);
    private _unloadComponent(componentRef);
    tick(): void;
    ngOnDestroy(): void;
    readonly viewCount: number;
    readonly componentTypes: Type<any>[];
    readonly components: ComponentRef<any>[];
    readonly isStable: Observable<boolean>;
}
}
declare module '@angular/core/src/application_ref' {
export * from '~@angular/core/src/application_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/application_tokens.d.ts
declare module '~@angular/core/src/application_tokens' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { InjectionToken } from '~@angular/core/src/di';
import { ComponentRef } from '~@angular/core/src/linker/component_factory';
/**
 * A DI Token representing a unique string id assigned to the application by Angular and used
 * primarily for prefixing application attributes and CSS styles when
 * {@link ViewEncapsulation#Emulated} is being used.
 *
 * If you need to avoid randomly generated value to be used as an application id, you can provide
 * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
 * using this token.
 * @experimental
 */
export const APP_ID: InjectionToken<string>;
export function _appIdRandomProviderFactory(): string;
/**
 * Providers that will generate a random APP_ID_TOKEN.
 * @experimental
 */
export const APP_ID_RANDOM_PROVIDER: {
    provide: InjectionToken<string>;
    useFactory: () => string;
    deps: any[];
};
/**
 * A function that will be executed when a platform is initialized.
 * @experimental
 */
export const PLATFORM_INITIALIZER: InjectionToken<(() => void)[]>;
/**
 * A token that indicates an opaque platform id.
 * @experimental
 */
export const PLATFORM_ID: InjectionToken<Object>;
/**
 * All callbacks provided via this token will be called for every component that is bootstrapped.
 * Signature of the callback:
 *
 * `(componentRef: ComponentRef) => void`.
 *
 * @experimental
 */
export const APP_BOOTSTRAP_LISTENER: InjectionToken<((compRef: ComponentRef<any>) => void)[]>;
/**
 * A token which indicates the root directory of the application
 * @experimental
 */
export const PACKAGE_ROOT_URL: InjectionToken<string>;
}
declare module '@angular/core/src/application_tokens' {
export * from '~@angular/core/src/application_tokens';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/differs/keyvalue_differs.d.ts
declare module '~@angular/core/src/change_detection/differs/keyvalue_differs' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Provider } from '~@angular/core/src/di';
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detector_ref';
/**
 * A differ that tracks changes made to an object over time.
 *
 * @stable
 */
export interface KeyValueDiffer<K, V> {
    /**
     * Compute a difference between the previous state and the new `object` state.
     *
     * @param object containing the new value.
     * @returns an object describing the difference. The return value is only valid until the next
     * `diff()` invocation.
     */
    diff(object: Map<K, V>): KeyValueChanges<K, V>;
    /**
     * Compute a difference between the previous state and the new `object` state.
     *
     * @param object containing the new value.
     * @returns an object describing the difference. The return value is only valid until the next
     * `diff()` invocation.
     */
    diff(object: {
        [key: string]: V;
    }): KeyValueChanges<string, V>;
}
/**
 * An object describing the changes in the `Map` or `{[k:string]: string}` since last time
 * `KeyValueDiffer#diff()` was invoked.
 *
 * @stable
 */
export interface KeyValueChanges<K, V> {
    /**
     * Iterate over all changes. `KeyValueChangeRecord` will contain information about changes
     * to each item.
     */
    forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    /**
     * Iterate over changes in the order of original Map showing where the original items
     * have moved.
     */
    forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    /**
     * Iterate over all keys for which values have changed.
     */
    forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    /**
     * Iterate over all added items.
     */
    forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    /**
     * Iterate over all removed items.
     */
    forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
}
/**
 * Record representing the item change information.
 *
 * @stable
 */
export interface KeyValueChangeRecord<K, V> {
    /**
     * Current key in the Map.
     */
    readonly key: K;
    /**
     * Current value for the key or `null` if removed.
     */
    readonly currentValue: V | null;
    /**
     * Previous value for the key or `null` if added.
     */
    readonly previousValue: V | null;
}
/**
 * Provides a factory for {@link KeyValueDiffer}.
 *
 * @stable
 */
export interface KeyValueDifferFactory {
    /**
     * Test to see if the differ knows how to diff this kind of object.
     */
    supports(objects: any): boolean;
    /**
     * Create a `KeyValueDiffer`.
     */
    create<K, V>(): KeyValueDiffer<K, V>;
    /**
     * @deprecated v4.0.0 - ChangeDetectorRef is not used and is no longer a parameter
     */
    create<K, V>(_cdr?: ChangeDetectorRef): KeyValueDiffer<K, V>;
}
/**
 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
 * @stable
 */
export class KeyValueDiffers {
    /**
     * @deprecated v4.0.0 - Should be private.
     */
    factories: KeyValueDifferFactory[];
    constructor(factories: KeyValueDifferFactory[]);
    static create<S>(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers;
    /**
     * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the
     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
     * {@link KeyValueDiffers} instance.
     *
     * The following example shows how to extend an existing list of factories,
           * which will only be applied to the injector for this component and its children.
           * This step is all that's required to make a new {@link KeyValueDiffer} available.
     *
     * ### Example
     *
     * ```
     * @Component({
     *   viewProviders: [
     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
     *   ]
     * })
     * ```
     */
    static extend<S>(factories: KeyValueDifferFactory[]): Provider;
    find(kv: any): KeyValueDifferFactory;
}
}
declare module '@angular/core/src/change_detection/differs/keyvalue_differs' {
export * from '~@angular/core/src/change_detection/differs/keyvalue_differs';
}

// Generated by typings
// Source: node_modules/@angular/core/src/metadata/lifecycle_hooks.d.ts
declare module '~@angular/core/src/metadata/lifecycle_hooks' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { SimpleChange } from '~@angular/core/src/change_detection/change_detection_util';
/**
 * @stable
 */
export enum LifecycleHooks {
    OnInit = 0,
    OnDestroy = 1,
    DoCheck = 2,
    OnChanges = 3,
    AfterContentInit = 4,
    AfterContentChecked = 5,
    AfterViewInit = 6,
    AfterViewChecked = 7,
}
/**
 * A `changes` object whose keys are property names and
 * values are instances of {@link SimpleChange}. See {@link OnChanges}
 * @stable
 */
export interface SimpleChanges {
    [propName: string]: SimpleChange;
}
export const LIFECYCLE_HOOKS_VALUES: LifecycleHooks[];
/**
 * @whatItDoes Lifecycle hook that is called when any data-bound property of a directive changes.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}
 *
 * @description
 * `ngOnChanges` is called right after the data-bound properties have been checked and before view
 * and content children are checked if at least one of them has changed.
 * The `changes` parameter contains the changed properties.
 *
 * See {@linkDocs guide/lifecycle-hooks#onchanges "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export interface OnChanges {
    ngOnChanges(changes: SimpleChanges): void;
}
/**
 * @whatItDoes Lifecycle hook that is called after data-bound properties of a directive are
 * initialized.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}
 *
 * @description
 * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
 * first time, and before any of its children have been checked. It is invoked only once when the
 * directive is instantiated.
 *
 * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export interface OnInit {
    ngOnInit(): void;
}
/**
 * @whatItDoes Lifecycle hook that is called when Angular dirty checks a directive.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}
 *
 * @description
 * `ngDoCheck` gets called to check the changes in the directives in addition to the default
 * algorithm. The default change detection algorithm looks for differences by comparing
 * bound-property values by reference across change detection runs.
 *
 * Note that a directive typically should not use both `DoCheck` and {@link OnChanges} to respond to
 * changes on the same input, as `ngOnChanges` will continue to be called when the default change
 * detector detects changes.
 *
 * See {@link KeyValueDiffers} and {@link IterableDiffers} for implementing custom dirty checking
 * for collections.
 *
 * See {@linkDocs guide/lifecycle-hooks#docheck "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export interface DoCheck {
    ngDoCheck(): void;
}
/**
 * @whatItDoes Lifecycle hook that is called when a directive, pipe or service is destroyed.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}
 *
 * @description
 * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
 * instance is destroyed.
 *
 * See {@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export interface OnDestroy {
    ngOnDestroy(): void;
}
/**
 *
 * @whatItDoes Lifecycle hook that is called after a directive's content has been fully
 * initialized.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}
 *
 * @description
 * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export interface AfterContentInit {
    ngAfterContentInit(): void;
}
/**
 * @whatItDoes Lifecycle hook that is called after every check of a directive's content.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}
 *
 * @description
 * See {@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export interface AfterContentChecked {
    ngAfterContentChecked(): void;
}
/**
 * @whatItDoes Lifecycle hook that is called after a component's view has been fully
 * initialized.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}
 *
 * @description
 * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export interface AfterViewInit {
    ngAfterViewInit(): void;
}
/**
 * @whatItDoes Lifecycle hook that is called after every check of a component's view.
 * @howToUse
 * {@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}
 *
 * @description
 * See {@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
 *
 * @stable
 */
export interface AfterViewChecked {
    ngAfterViewChecked(): void;
}
}
declare module '@angular/core/src/metadata/lifecycle_hooks' {
export * from '~@angular/core/src/metadata/lifecycle_hooks';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/change_detection_util.d.ts
declare module '~@angular/core/src/change_detection/change_detection_util' {
export function devModeEqual(a: any, b: any): boolean;
/**
 * Indicates that the result of a {@link Pipe} transformation has changed even though the
 * reference
 * has not changed.
 *
 * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
 *
 * Example:
 *
 * ```
 * if (this._latestValue === this._latestReturnedValue) {
 *    return this._latestReturnedValue;
 *  } else {
 *    this._latestReturnedValue = this._latestValue;
 *    return WrappedValue.wrap(this._latestValue); // this will force update
 *  }
 * ```
 * @stable
 */
export class WrappedValue {
    wrapped: any;
    constructor(wrapped: any);
    static wrap(value: any): WrappedValue;
}
/**
 * Helper class for unwrapping WrappedValue s
 */
export class ValueUnwrapper {
    hasWrappedValue: boolean;
    unwrap(value: any): any;
    reset(): void;
}
/**
 * Represents a basic change from a previous to a new value.
 * @stable
 */
export class SimpleChange {
    previousValue: any;
    currentValue: any;
    firstChange: boolean;
    constructor(previousValue: any, currentValue: any, firstChange: boolean);
    /**
     * Check whether the new value is the first value assigned.
     */
    isFirstChange(): boolean;
}
export function isListLikeIterable(obj: any): boolean;
export function areIterablesEqual(a: any, b: any, comparator: (a: any, b: any) => boolean): boolean;
export function iterateListLike(obj: any, fn: (p: any) => any): void;
export function isJsObject(o: any): boolean;
}
declare module '@angular/core/src/change_detection/change_detection_util' {
export * from '~@angular/core/src/change_detection/change_detection_util';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/change_detector_ref.d.ts
declare module '~@angular/core/src/change_detection/change_detector_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @stable
 */
export abstract class ChangeDetectorRef {
    /**
     * Marks all {@link ChangeDetectionStrategy#OnPush} ancestors as to be checked.
     *
     * <!-- TODO: Add a link to a chapter on OnPush components -->
     *
     * ### Example ([live demo](http://plnkr.co/edit/GC512b?p=preview))
     *
     * ```typescript
     * @Component({
     *   selector: 'cmp',
     *   changeDetection: ChangeDetectionStrategy.OnPush,
     *   template: `Number of ticks: {{numberOfTicks}}`
     * })
     * class Cmp {
     *   numberOfTicks = 0;
     *
     *   constructor(ref: ChangeDetectorRef) {
     *     setInterval(() => {
     *       this.numberOfTicks ++
     *       // the following is required, otherwise the view will not be updated
     *       this.ref.markForCheck();
     *     }, 1000);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   changeDetection: ChangeDetectionStrategy.OnPush,
     *   template: `
     *     <cmp><cmp>
     *   `,
     * })
     * class App {
     * }
     * ```
     */
    abstract markForCheck(): void;
    /**
     * Detaches the change detector from the change detector tree.
     *
     * The detached change detector will not be checked until it is reattached.
     *
     * This can also be used in combination with {@link ChangeDetectorRef#detectChanges} to implement
     * local change
     * detection checks.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
     *
     * ### Example
     *
     * The following example defines a component with a large list of readonly data.
     * Imagine the data changes constantly, many times per second. For performance reasons,
     * we want to check and update the list every five seconds. We can do that by detaching
     * the component's change detector and doing a local check every five seconds.
     *
     * ```typescript
     * class DataProvider {
     *   // in a real application the returned data will be different every time
     *   get data() {
     *     return [1,2,3,4,5];
     *   }
     * }
     *
     * @Component({
     *   selector: 'giant-list',
     *   template: `
     *     <li *ngFor="let d of dataProvider.data">Data {{d}}</lig>
     *   `,
     * })
     * class GiantList {
     *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {
     *     ref.detach();
     *     setInterval(() => {
     *       this.ref.detectChanges();
     *     }, 5000);
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   providers: [DataProvider],
     *   template: `
     *     <giant-list><giant-list>
     *   `,
     * })
     * class App {
     * }
     * ```
     */
    abstract detach(): void;
    /**
     * Checks the change detector and its children.
     *
     * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement local
     * change detection
     * checks.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
     *
     * ### Example
     *
     * The following example defines a component with a large list of readonly data.
     * Imagine, the data changes constantly, many times per second. For performance reasons,
     * we want to check and update the list every five seconds.
     *
     * We can do that by detaching the component's change detector and doing a local change detection
     * check
     * every five seconds.
     *
     * See {@link ChangeDetectorRef#detach} for more information.
     */
    abstract detectChanges(): void;
    /**
     * Checks the change detector and its children, and throws if any changes are detected.
     *
     * This is used in development mode to verify that running change detection doesn't introduce
     * other changes.
     */
    abstract checkNoChanges(): void;
    /**
     * Reattach the change detector to the change detector tree.
     *
     * This also marks OnPush ancestors as to be checked. This reattached change detector will be
     * checked during the next change detection run.
     *
     * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
     *
     * ### Example ([live demo](http://plnkr.co/edit/aUhZha?p=preview))
     *
     * The following example creates a component displaying `live` data. The component will detach
     * its change detector from the main change detector tree when the component's live property
     * is set to false.
     *
     * ```typescript
     * class DataProvider {
     *   data = 1;
     *
     *   constructor() {
     *     setInterval(() => {
     *       this.data = this.data * 2;
     *     }, 500);
     *   }
     * }
     *
     * @Component({
     *   selector: 'live-data',
     *   inputs: ['live'],
     *   template: 'Data: {{dataProvider.data}}'
     * })
     * class LiveData {
     *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {}
     *
     *   set live(value) {
     *     if (value)
     *       this.ref.reattach();
     *     else
     *       this.ref.detach();
     *   }
     * }
     *
     * @Component({
     *   selector: 'app',
     *   providers: [DataProvider],
     *   template: `
     *     Live Update: <input type="checkbox" [(ngModel)]="live">
     *     <live-data [live]="live"><live-data>
     *   `,
     * })
     * class App {
     *   live = true;
     * }
     * ```
     */
    abstract reattach(): void;
}
}
declare module '@angular/core/src/change_detection/change_detector_ref' {
export * from '~@angular/core/src/change_detection/change_detector_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/constants.d.ts
declare module '~@angular/core/src/change_detection/constants' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Describes within the change detector which strategy will be used the next time change
 * detection is triggered.
 * @stable
 */
export enum ChangeDetectionStrategy {
    /**
     * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
     */
    OnPush = 0,
    /**
     * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
     */
    Default = 1,
}
/**
 * Describes the status of the detector.
 */
export enum ChangeDetectorStatus {
    /**
     * `CheckOnce` means that after calling detectChanges the mode of the change detector
     * will become `Checked`.
     */
    CheckOnce = 0,
    /**
     * `Checked` means that the change detector should be skipped until its mode changes to
     * `CheckOnce`.
     */
    Checked = 1,
    /**
     * `CheckAlways` means that after calling detectChanges the mode of the change detector
     * will remain `CheckAlways`.
     */
    CheckAlways = 2,
    /**
     * `Detached` means that the change detector sub tree is not a part of the main tree and
     * should be skipped.
     */
    Detached = 3,
    /**
     * `Errored` means that the change detector encountered an error checking a binding
     * or calling a directive lifecycle method and is now in an inconsistent state. Change
     * detectors in this state will no longer detect changes.
     */
    Errored = 4,
    /**
     * `Destroyed` means that the change detector is destroyed.
     */
    Destroyed = 5,
}
export function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy): boolean;
}
declare module '@angular/core/src/change_detection/constants' {
export * from '~@angular/core/src/change_detection/constants';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/pipe_transform.d.ts
declare module '~@angular/core/src/change_detection/pipe_transform' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * To create a Pipe, you must implement this interface.
 *
 * Angular invokes the `transform` method with the value of a binding
 * as the first argument, and any parameters as the second argument in list form.
 *
 * ## Syntax
 *
 * `value | pipeName[:arg0[:arg1...]]`
 *
 * ### Example ([live demo](http://plnkr.co/edit/f5oyIked9M2cKzvZNKHV?p=preview))
 *
 * The `RepeatPipe` below repeats the value as many times as indicated by the first argument:
 *
 * ```
 * import {Pipe, PipeTransform} from '@angular/core';
 *
 * @Pipe({name: 'repeat'})
 * export class RepeatPipe implements PipeTransform {
 *   transform(value: any, times: number) {
 *     return value.repeat(times);
 *   }
 * }
 * ```
 *
 * Invoking `{{ 'ok' | repeat:3 }}` in a template produces `okokok`.
 *
 * @stable
 */
export interface PipeTransform {
    transform(value: any, ...args: any[]): any;
}
}
declare module '@angular/core/src/change_detection/pipe_transform' {
export * from '~@angular/core/src/change_detection/pipe_transform';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/change_detection.d.ts
declare module '~@angular/core/src/change_detection/change_detection' {
import { IterableDiffers } from '~@angular/core/src/change_detection/differs/iterable_differs';
import { KeyValueDiffers } from '~@angular/core/src/change_detection/differs/keyvalue_differs';
export { SimpleChanges } from '~@angular/core/src/metadata/lifecycle_hooks';
export { SimpleChange, ValueUnwrapper, WrappedValue, devModeEqual } from '~@angular/core/src/change_detection/change_detection_util';
export { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detector_ref';
export { ChangeDetectionStrategy, ChangeDetectorStatus, isDefaultChangeDetectionStrategy } from '~@angular/core/src/change_detection/constants';
export { DefaultIterableDifferFactory } from '~@angular/core/src/change_detection/differs/default_iterable_differ';
export { DefaultIterableDiffer } from '~@angular/core/src/change_detection/differs/default_iterable_differ';
export { DefaultKeyValueDifferFactory } from '~@angular/core/src/change_detection/differs/default_keyvalue_differ';
export { CollectionChangeRecord, IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, IterableDiffers, NgIterable, TrackByFn, TrackByFunction } from '~@angular/core/src/change_detection/differs/iterable_differs';
export { KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory, KeyValueDiffers } from '~@angular/core/src/change_detection/differs/keyvalue_differs';
export { PipeTransform } from '~@angular/core/src/change_detection/pipe_transform';
export const defaultIterableDiffers: IterableDiffers;
export const defaultKeyValueDiffers: KeyValueDiffers;
}
declare module '@angular/core/src/change_detection/change_detection' {
export * from '~@angular/core/src/change_detection/change_detection';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/differs/iterable_differs.d.ts
declare module '~@angular/core/src/change_detection/differs/iterable_differs' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Provider } from '~@angular/core/src/di';
import { ChangeDetectorRef } from '~@angular/core/src/change_detection/change_detector_ref';
/**
 * A type describing supported interable types.
 *
 * @stable
 */
export type NgIterable<T> = Array<T> | Iterable<T>;
/**
 * A strategy for tracking changes over time to an iterable. Used by {@link NgFor} to
 * respond to changes in an iterable by effecting equivalent changes in the DOM.
 *
 * @stable
 */
export interface IterableDiffer<V> {
    /**
     * Compute a difference between the previous state and the new `object` state.
     *
     * @param object containing the new value.
     * @returns an object describing the difference. The return value is only valid until the next
     * `diff()` invocation.
     */
    diff(object: NgIterable<V>): IterableChanges<V> | null;
}
/**
 * An object describing the changes in the `Iterable` collection since last time
 * `IterableDiffer#diff()` was invoked.
 *
 * @stable
 */
export interface IterableChanges<V> {
    /**
     * Iterate over all changes. `IterableChangeRecord` will contain information about changes
     * to each item.
     */
    forEachItem(fn: (record: IterableChangeRecord<V>) => void): void;
    /**
     * Iterate over a set of operations which when applied to the original `Iterable` will produce the
     * new `Iterable`.
     *
     * NOTE: These are not necessarily the actual operations which were applied to the original
     * `Iterable`, rather these are a set of computed operations which may not be the same as the
     * ones applied.
     *
     * @param record A change which needs to be applied
     * @param previousIndex The `IterableChangeRecord#previousIndex` of the `record` refers to the
     *        original `Iterable` location, where as `previousIndex` refers to the transient location
     *        of the item, after applying the operations up to this point.
     * @param currentIndex The `IterableChangeRecord#currentIndex` of the `record` refers to the
     *        original `Iterable` location, where as `currentIndex` refers to the transient location
     *        of the item, after applying the operations up to this point.
     */
    forEachOperation(fn: (record: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;
    /**
     * Iterate over changes in the order of original `Iterable` showing where the original items
     * have moved.
     */
    forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void;
    /** Iterate over all added items. */
    forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void;
    /** Iterate over all moved items. */
    forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void;
    /** Iterate over all removed items. */
    forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void;
    /** Iterate over all items which had their identity (as computed by the `trackByFn`) changed. */
    forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void;
}
/**
 * Record representing the item change information.
 *
 * @stable
 */
export interface IterableChangeRecord<V> {
    /** Current index of the item in `Iterable` or null if removed. */
    readonly currentIndex: number | null;
    /** Previous index of the item in `Iterable` or null if added. */
    readonly previousIndex: number | null;
    /** The item. */
    readonly item: V;
    /** Track by identity as computed by the `trackByFn`. */
    readonly trackById: any;
}
/**
 * @deprecated v4.0.0 - Use IterableChangeRecord instead.
 */
export interface CollectionChangeRecord<V> extends IterableChangeRecord<V> {
}
/**
 * Nolonger used.
 *
 * @deprecated v4.0.0 - Use TrackByFunction instead
 */
export interface TrackByFn {
    (index: number, item: any): any;
}
/**
 * An optional function passed into {@link NgForOf} that defines how to track
 * items in an iterable (e.g. fby index or id)
 *
 * @stable
 */
export interface TrackByFunction<T> {
    (index: number, item: T): any;
}
/**
 * Provides a factory for {@link IterableDiffer}.
 *
 * @stable
 */
export interface IterableDifferFactory {
    supports(objects: any): boolean;
    create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>;
    /**
     * @deprecated v4.0.0 - ChangeDetectorRef is not used and is no longer a parameter
     */
    create<V>(_cdr?: ChangeDetectorRef | TrackByFunction<V>, trackByFn?: TrackByFunction<V>): IterableDiffer<V>;
}
/**
 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
 * @stable
 */
export class IterableDiffers {
    /**
     * @deprecated v4.0.0 - Should be private
     */
    factories: IterableDifferFactory[];
    constructor(factories: IterableDifferFactory[]);
    static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers;
    /**
     * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the
     * inherited {@link IterableDiffers} instance with the provided factories and return a new
     * {@link IterableDiffers} instance.
     *
     * The following example shows how to extend an existing list of factories,
     * which will only be applied to the injector for this component and its children.
     * This step is all that's required to make a new {@link IterableDiffer} available.
     *
     * ### Example
     *
     * ```
     * @Component({
     *   viewProviders: [
     *     IterableDiffers.extend([new ImmutableListDiffer()])
     *   ]
     * })
     * ```
     */
    static extend(factories: IterableDifferFactory[]): Provider;
    find(iterable: any): IterableDifferFactory;
}
export function getTypeNameForDebugging(type: any): string;
}
declare module '@angular/core/src/change_detection/differs/iterable_differs' {
export * from '~@angular/core/src/change_detection/differs/iterable_differs';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/differs/default_iterable_differ.d.ts
declare module '~@angular/core/src/change_detection/differs/default_iterable_differ' {
import { IterableChangeRecord, IterableChanges, IterableDiffer, IterableDifferFactory, NgIterable, TrackByFunction } from '~@angular/core/src/change_detection/differs/iterable_differs';
export class DefaultIterableDifferFactory implements IterableDifferFactory {
    constructor();
    supports(obj: Object | null | undefined): boolean;
    create<V>(trackByFn?: TrackByFunction<V>): DefaultIterableDiffer<V>;
}
/**
 * @deprecated v4.0.0 - Should not be part of public API.
 */
export class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {
    private _length;
    private _collection;
    private _linkedRecords;
    private _unlinkedRecords;
    private _previousItHead;
    private _itHead;
    private _itTail;
    private _additionsHead;
    private _additionsTail;
    private _movesHead;
    private _movesTail;
    private _removalsHead;
    private _removalsTail;
    private _identityChangesHead;
    private _identityChangesTail;
    private _trackByFn;
    constructor(trackByFn?: TrackByFunction<V>);
    readonly collection: V[] | Iterable<V> | null;
    readonly length: number;
    forEachItem(fn: (record: IterableChangeRecord_<V>) => void): void;
    forEachOperation(fn: (item: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;
    forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void): void;
    forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
    forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
    forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;
    forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void): void;
    diff(collection: NgIterable<V>): DefaultIterableDiffer<V> | null;
    onDestroy(): void;
    check(collection: NgIterable<V>): boolean;
    readonly isDirty: boolean;
    private _addToRemovals(record);
    toString(): string;
}
/**
 * @stable
 */
export class IterableChangeRecord_<V> implements IterableChangeRecord<V> {
    item: V;
    trackById: any;
    currentIndex: number | null;
    previousIndex: number | null;
    constructor(item: V, trackById: any);
    toString(): string;
}
}
declare module '@angular/core/src/change_detection/differs/default_iterable_differ' {
export * from '~@angular/core/src/change_detection/differs/default_iterable_differ';
}

// Generated by typings
// Source: node_modules/@angular/core/src/change_detection/differs/default_keyvalue_differ.d.ts
declare module '~@angular/core/src/change_detection/differs/default_keyvalue_differ' {
import { KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory } from '~@angular/core/src/change_detection/differs/keyvalue_differs';
export class DefaultKeyValueDifferFactory<K, V> implements KeyValueDifferFactory {
    constructor();
    supports(obj: any): boolean;
    create<K, V>(): DefaultKeyValueDiffer<K, V>;
}
export class DefaultKeyValueDiffer<K, V> implements KeyValueDiffer<K, V>, KeyValueChanges<K, V> {
    private _records;
    private _mapHead;
    private _appendAfter;
    private _previousMapHead;
    private _changesHead;
    private _changesTail;
    private _additionsHead;
    private _additionsTail;
    private _removalsHead;
    private _removalsTail;
    readonly isDirty: boolean;
    forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;
    diff(map?: Map<any, any> | {
        [k: string]: any;
    } | null): any;
    onDestroy(): void;
    /**
     * Check the current state of the map vs the previous.
     * The algorithm is optimised for when the keys do no change.
     */
    check(map: Map<any, any> | {
        [k: string]: any;
    }): boolean;
    /**
     * Inserts a record before `before` or append at the end of the list when `before` is null.
     *
     * Notes:
     * - This method appends at `this._appendAfter`,
     * - This method updates `this._appendAfter`,
     * - The return value is the new value for the insertion pointer.
     */
    private _insertBeforeOrAppend(before, record);
    private _getOrCreateRecordForKey(key, value);
    private _maybeAddToChanges(record, newValue);
    private _addToAdditions(record);
    private _addToChanges(record);
    toString(): string;
}
}
declare module '@angular/core/src/change_detection/differs/default_keyvalue_differ' {
export * from '~@angular/core/src/change_detection/differs/default_keyvalue_differ';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/injector.d.ts
declare module '~@angular/core/src/di/injector' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '~@angular/core/src/type';
import { InjectionToken } from '~@angular/core/src/di/injection_token';
export const THROW_IF_NOT_FOUND: Object;
/**
 * @whatItDoes Injector interface
 * @howToUse
 * ```
 * const injector: Injector = ...;
 * injector.get(...);
 * ```
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/injector_spec.ts region='Injector'}
 *
 * `Injector` returns itself when given `Injector` as a token:
 * {@example core/di/ts/injector_spec.ts region='injectInjector'}
 *
 * @stable
 */
export abstract class Injector {
    static THROW_IF_NOT_FOUND: Object;
    static NULL: Injector;
    /**
     * Retrieves an instance from the injector based on the provided token.
     * If not found:
     * - Throws an error if no `notFoundValue` that is not equal to
     * Injector.THROW_IF_NOT_FOUND is given
     * - Returns the `notFoundValue` otherwise
     */
    abstract get<T>(token: Type<T> | InjectionToken<T>, notFoundValue?: T): T;
    /**
     * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>
     * @suppress {duplicate}
     */
    abstract get(token: any, notFoundValue?: any): any;
}
}
declare module '@angular/core/src/di/injector' {
export * from '~@angular/core/src/di/injector';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/provider.d.ts
declare module '~@angular/core/src/di/provider' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '~@angular/core/src/type';
/**
 * @whatItDoes Configures the {@link Injector} to return an instance of `Type` when `Type' is used
 * as token.
 * @howToUse
 * ```
 * @Injectable()
 * class MyService {}
 *
 * const provider: TypeProvider = MyService;
 * ```
 *
 * @description
 *
 * Create an instance by invoking the `new` operator and supplying additional arguments.
 * This form is a short form of `TypeProvider`;
 *
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='TypeProvider'}
 *
 * @stable
 */
export interface TypeProvider extends Type<any> {
}
/**
 * @whatItDoes Configures the {@link Injector} to return a value for a token.
 * @howToUse
 * ```
 * const provider: ValueProvider = {provide: 'someToken', useValue: 'someValue'};
 * ```
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='ValueProvider'}
 *
 * @stable
 */
export interface ValueProvider {
    /**
     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
     */
    provide: any;
    /**
     * The value to inject.
     */
    useValue: any;
    /**
     * If true, then injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     *
     * ### Example
     *
     * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
     */
    multi?: boolean;
}
/**
 * @whatItDoes Configures the {@link Injector} to return an instance of `useClass` for a token.
 * @howToUse
 * ```
 * @Injectable()
 * class MyService {}
 *
 * const provider: ClassProvider = {provide: 'someToken', useClass: MyService};
 * ```
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='ClassProvider'}
 *
 * Note that following two providers are not equal:
 * {@example core/di/ts/provider_spec.ts region='ClassProviderDifference'}
 *
 * @stable
 */
export interface ClassProvider {
    /**
     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
     */
    provide: any;
    /**
     * Class to instantiate for the `token`.
     */
    useClass: Type<any>;
    /**
     * If true, then injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     *
     * ### Example
     *
     * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
     */
    multi?: boolean;
}
/**
 * @whatItDoes Configures the {@link Injector} to return a value of another `useExisting` token.
 * @howToUse
 * ```
 * const provider: ExistingProvider = {provide: 'someToken', useExisting: 'someOtherToken'};
 * ```
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='ExistingProvider'}
 *
 * @stable
 */
export interface ExistingProvider {
    /**
     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
     */
    provide: any;
    /**
     * Existing `token` to return. (equivalent to `injector.get(useExisting)`)
     */
    useExisting: any;
    /**
     * If true, then injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     *
     * ### Example
     *
     * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
     */
    multi?: boolean;
}
/**
 * @whatItDoes Configures the {@link Injector} to return a value by invoking a `useFactory`
 * function.
 * @howToUse
 * ```
 * function serviceFactory() { ... }
 *
 * const provider: FactoryProvider = {provide: 'someToken', useFactory: serviceFactory, deps: []};
 * ```
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * ### Example
 *
 * {@example core/di/ts/provider_spec.ts region='FactoryProvider'}
 *
 * Dependencies can also be marked as optional:
 * {@example core/di/ts/provider_spec.ts region='FactoryProviderOptionalDeps'}
 *
 * @stable
 */
export interface FactoryProvider {
    /**
     * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`).
     */
    provide: any;
    /**
     * A function to invoke to create a value for this `token`. The function is invoked with
     * resolved values of `token`s in the `deps` field.
     */
    useFactory: Function;
    /**
     * A list of `token`s which need to be resolved by the injector. The list of values is then
     * used as arguments to the `useFactory` function.
     */
    deps?: any[];
    /**
     * If true, then injector returns an array of instances. This is useful to allow multiple
     * providers spread across many files to provide configuration information to a common token.
     *
     * ### Example
     *
     * {@example core/di/ts/provider_spec.ts region='MultiProviderAspect'}
     */
    multi?: boolean;
}
/**
 * @whatItDoes Describes how the {@link Injector} should be configured.
 * @howToUse
 * See {@link TypeProvider}, {@link ValueProvider}, {@link ClassProvider}, {@link ExistingProvider},
 * {@link FactoryProvider}.
 *
 * @description
 * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
 *
 * @stable
 */
export type Provider = TypeProvider | ValueProvider | ClassProvider | ExistingProvider | FactoryProvider | any[];
}
declare module '@angular/core/src/di/provider' {
export * from '~@angular/core/src/di/provider';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/reflective_injector.d.ts
declare module '~@angular/core/src/di/reflective_injector' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injector } from '~@angular/core/src/di/injector';
import { Provider } from '~@angular/core/src/di/provider';
import { ResolvedReflectiveProvider } from '~@angular/core/src/di/reflective_provider';
/**
 * A ReflectiveDependency injection container used for instantiating objects and resolving
 * dependencies.
 *
 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
 * constructor dependencies.
 *
 * In typical use, application code asks for the dependencies in the constructor and they are
 * resolved by the `Injector`.
 *
 * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
 *
 * The following example creates an `Injector` configured to create `Engine` and `Car`.
 *
 * ```typescript
 * @Injectable()
 * class Engine {
 * }
 *
 * @Injectable()
 * class Car {
 *   constructor(public engine:Engine) {}
 * }
 *
 * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
 * var car = injector.get(Car);
 * expect(car instanceof Car).toBe(true);
 * expect(car.engine instanceof Engine).toBe(true);
 * ```
 *
 * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
 * resolve all of the object's dependencies automatically.
 *
 * @stable
 */
export abstract class ReflectiveInjector implements Injector {
    /**
     * Turns an array of provider definitions into an array of resolved providers.
     *
     * A resolution is a process of flattening multiple nested arrays and converting individual
     * providers into an array of {@link ResolvedReflectiveProvider}s.
     *
     * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
     *
     * expect(providers.length).toEqual(2);
     *
     * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
     * expect(providers[0].key.displayName).toBe("Car");
     * expect(providers[0].dependencies.length).toEqual(1);
     * expect(providers[0].factory).toBeDefined();
     *
     * expect(providers[1].key.displayName).toBe("Engine");
     * });
     * ```
     *
     * See {@link ReflectiveInjector#fromResolvedProviders} for more info.
     */
    static resolve(providers: Provider[]): ResolvedReflectiveProvider[];
    /**
     * Resolves an array of providers and creates an injector from those providers.
     *
     * The passed-in providers can be an array of `Type`, {@link Provider},
     * or a recursive array of more providers.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
     * expect(injector.get(Car) instanceof Car).toBe(true);
     * ```
     *
     * This function is slower than the corresponding `fromResolvedProviders`
     * because it needs to resolve the passed-in providers first.
     * See {@link ReflectiveInjector#resolve} and {@link ReflectiveInjector#fromResolvedProviders}.
     */
    static resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector;
    /**
     * Creates an injector from previously resolved providers.
     *
     * This API is the recommended way to construct injectors in performance-sensitive parts.
     *
     * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var providers = ReflectiveInjector.resolve([Car, Engine]);
     * var injector = ReflectiveInjector.fromResolvedProviders(providers);
     * expect(injector.get(Car) instanceof Car).toBe(true);
     * ```
     * @experimental
     */
    static fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector): ReflectiveInjector;
    /**
     * Parent of this injector.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
     *
     * ```typescript
     * var parent = ReflectiveInjector.resolveAndCreate([]);
     * var child = parent.resolveAndCreateChild([]);
     * expect(child.parent).toBe(parent);
     * ```
     */
    readonly abstract parent: Injector | null;
    /**
     * Resolves an array of providers and creates a child injector from those providers.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * The passed-in providers can be an array of `Type`, {@link Provider},
     * or a recursive array of more providers.
     *
     * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
     *
     * ```typescript
     * class ParentProvider {}
     * class ChildProvider {}
     *
     * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
     * var child = parent.resolveAndCreateChild([ChildProvider]);
     *
     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
     * ```
     *
     * This function is slower than the corresponding `createChildFromResolved`
     * because it needs to resolve the passed-in providers first.
     * See {@link ReflectiveInjector#resolve} and {@link ReflectiveInjector#createChildFromResolved}.
     */
    abstract resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;
    /**
     * Creates a child injector from previously resolved providers.
     *
     * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
     * -->
     *
     * This API is the recommended way to construct injectors in performance-sensitive parts.
     *
     * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
     *
     * ```typescript
     * class ParentProvider {}
     * class ChildProvider {}
     *
     * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
     * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
     *
     * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
     * var child = parent.createChildFromResolved(childProviders);
     *
     * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
     * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
     * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
     * ```
     */
    abstract createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;
    /**
     * Resolves a provider and instantiates an object in the context of the injector.
     *
     * The created object does not get cached by the injector.
     *
     * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
     *
     * var car = injector.resolveAndInstantiate(Car);
     * expect(car.engine).toBe(injector.get(Engine));
     * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
     * ```
     */
    abstract resolveAndInstantiate(provider: Provider): any;
    /**
     * Instantiates an object using a resolved provider in the context of the injector.
     *
     * The created object does not get cached by the injector.
     *
     * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
     *
     * ```typescript
     * @Injectable()
     * class Engine {
     * }
     *
     * @Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
     * var carProvider = ReflectiveInjector.resolve([Car])[0];
     * var car = injector.instantiateResolved(carProvider);
     * expect(car.engine).toBe(injector.get(Engine));
     * expect(car).not.toBe(injector.instantiateResolved(carProvider));
     * ```
     */
    abstract instantiateResolved(provider: ResolvedReflectiveProvider): any;
    abstract get(token: any, notFoundValue?: any): any;
}
export class ReflectiveInjector_ implements ReflectiveInjector {
    keyIds: number[];
    objs: any[];
    /**
     * Private
     */
    constructor(_providers: ResolvedReflectiveProvider[], _parent?: Injector);
    get(token: any, notFoundValue?: any): any;
    readonly parent: Injector | null;
    resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;
    createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;
    resolveAndInstantiate(provider: Provider): any;
    instantiateResolved(provider: ResolvedReflectiveProvider): any;
    getProviderAtIndex(index: number): ResolvedReflectiveProvider;
    private _getMaxNumberOfObjects();
    private _instantiateProvider(provider);
    private _instantiate(provider, ResolvedReflectiveFactory);
    private _getByReflectiveDependency(dep);
    private _getByKey(key, visibility, notFoundValue);
    private _getObjByKeyId(keyId);
    readonly displayName: string;
    toString(): string;
}
}
declare module '@angular/core/src/di/reflective_injector' {
export * from '~@angular/core/src/di/reflective_injector';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/metadata.d.ts
declare module '~@angular/core/src/di/metadata' {
/**
 * Type of the Inject decorator / constructor function.
 *
 * @stable
 */
export interface InjectDecorator {
    /**
     * @whatItDoes A parameter decorator that specifies a dependency.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {
     *   constructor(@Inject("MyEngine") public engine:Engine) {}
     * }
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='Inject'}
     *
     * When `@Inject()` is not present, {@link Injector} will use the type annotation of the
     * parameter.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='InjectWithoutDecorator'}
     *
     * @stable
     */
    (token: any): any;
    new (token: any): Inject;
}
/**
 * Type of the Inject metadata.
 *
 * @stable
 */
export interface Inject {
    token: any;
}
/**
 * Inject decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Inject: InjectDecorator;
/**
 * Type of the Optional decorator / constructor function.
 *
 * @stable
 */
export interface OptionalDecorator {
    /**
     * @whatItDoes A parameter metadata that marks a dependency as optional.
     * {@link Injector} provides `null` if the dependency is not found.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {
     *   constructor(@Optional() public engine:Engine) {}
     * }
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='Optional'}
     *
     * @stable
     */
    (): any;
    new (): Optional;
}
/**
 * Type of the Optional metadata.
 *
 * @stable
 */
export interface Optional {
}
/**
 * Optional decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Optional: OptionalDecorator;
/**
 * Type of the Injectable decorator / constructor function.
 *
 * @stable
 */
export interface InjectableDecorator {
    /**
     * @whatItDoes A marker metadata that marks a class as available to {@link Injector} for creation.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {}
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='Injectable'}
     *
     * {@link Injector} will throw an error when trying to instantiate a class that
     * does not have `@Injectable` marker, as shown in the example below.
     *
     * {@example core/di/ts/metadata_spec.ts region='InjectableThrows'}
     *
     * @stable
     */
    (): any;
    new (): Injectable;
}
/**
 * Type of the Injectable metadata.
 *
 * @stable
 */
export interface Injectable {
}
/**
 * Injectable decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Injectable: InjectableDecorator;
/**
 * Type of the Self decorator / constructor function.
 *
 * @stable
 */
export interface SelfDecorator {
    /**
     * @whatItDoes Specifies that an {@link Injector} should retrieve a dependency only from itself.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {
     *   constructor(@Self() public engine:Engine) {}
     * }
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='Self'}
     *
     * @stable
     */
    (): any;
    new (): Self;
}
/**
 * Type of the Self metadata.
 *
 * @stable
 */
export interface Self {
}
/**
 * Self decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Self: SelfDecorator;
/**
 * Type of the SkipSelf decorator / constructor function.
 *
 * @stable
 */
export interface SkipSelfDecorator {
    /**
     * @whatItDoes Specifies that the dependency resolution should start from the parent injector.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {
     *   constructor(@SkipSelf() public engine:Engine) {}
     * }
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='SkipSelf'}
     *
     * @stable
     */
    (): any;
    new (): SkipSelf;
}
/**
 * Type of the SkipSelf metadata.
 *
 * @stable
 */
export interface SkipSelf {
}
/**
 * SkipSelf decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const SkipSelf: SkipSelfDecorator;
/**
 * Type of the Host decorator / constructor function.
 *
 * @stable
 */
export interface HostDecorator {
    /**
     * @whatItDoes Specifies that an injector should retrieve a dependency from any injector until
     * reaching the host element of the current component.
     * @howToUse
     * ```
     * @Injectable()
     * class Car {
     *   constructor(@Host() public engine:Engine) {}
     * }
     * ```
     *
     * @description
     * For more details, see the {@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
     *
     * ### Example
     *
     * {@example core/di/ts/metadata_spec.ts region='Host'}
     *
     * @stable
     */
    (): any;
    new (): Host;
}
/**
 * Type of the Host metadata.
 *
 * @stable
 */
export interface Host {
}
/**
 * Host decorator and metadata.
 *
 * @stable
 * @Annotation
 */
export const Host: HostDecorator;
}
declare module '@angular/core/src/di/metadata' {
export * from '~@angular/core/src/di/metadata';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/reflective_key.d.ts
declare module '~@angular/core/src/di/reflective_key' {
/**
 * A unique object used for retrieving items from the {@link ReflectiveInjector}.
 *
 * Keys have:
 * - a system-wide unique `id`.
 * - a `token`.
 *
 * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows
 * the
 * injector to store created objects in a more efficient way.
 *
 * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when
 * resolving
 * providers.
 * @experimental
 */
export class ReflectiveKey {
    token: Object;
    id: number;
    /**
     * Private
     */
    constructor(token: Object, id: number);
    /**
     * Returns a stringified token.
     */
    readonly displayName: string;
    /**
     * Retrieves a `Key` for a token.
     */
    static get(token: Object): ReflectiveKey;
    /**
     * @returns the number of keys registered in the system.
     */
    static readonly numberOfKeys: number;
}
}
declare module '@angular/core/src/di/reflective_key' {
export * from '~@angular/core/src/di/reflective_key';
}

// Generated by typings
// Source: node_modules/@angular/core/src/di/reflective_provider.d.ts
declare module '~@angular/core/src/di/reflective_provider' {
import { Self, SkipSelf } from '~@angular/core/src/di/metadata';
import { Provider } from '~@angular/core/src/di/provider';
import { ReflectiveKey } from '~@angular/core/src/di/reflective_key';
/**
 * `Dependency` is used by the framework to extend DI.
 * This is internal to Angular and should not be used directly.
 */
export class ReflectiveDependency {
    key: ReflectiveKey;
    optional: boolean;
    visibility: Self | SkipSelf | null;
    constructor(key: ReflectiveKey, optional: boolean, visibility: Self | SkipSelf | null);
    static fromKey(key: ReflectiveKey): ReflectiveDependency;
}
/**
 * An internal resolved representation of a {@link Provider} used by the {@link Injector}.
 *
 * It is usually created automatically by `Injector.resolveAndCreate`.
 *
 * It can be created manually, as follows:
 *
 * ### Example ([live demo](http://plnkr.co/edit/RfEnhh8kUEI0G3qsnIeT?p%3Dpreview&p=preview))
 *
 * ```typescript
 * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);
 * var injector = Injector.fromResolvedProviders(resolvedProviders);
 *
 * expect(injector.get('message')).toEqual('Hello');
 * ```
 *
 * @experimental
 */
export interface ResolvedReflectiveProvider {
    /**
     * A key, usually a `Type<any>`.
     */
    key: ReflectiveKey;
    /**
     * Factory function which can return an instance of an object represented by a key.
     */
    resolvedFactories: ResolvedReflectiveFactory[];
    /**
     * Indicates if the provider is a multi-provider or a regular provider.
     */
    multiProvider: boolean;
}
export class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {
    key: ReflectiveKey;
    resolvedFactories: ResolvedReflectiveFactory[];
    multiProvider: boolean;
    constructor(key: ReflectiveKey, resolvedFactories: ResolvedReflectiveFactory[], multiProvider: boolean);
    readonly resolvedFactory: ResolvedReflectiveFactory;
}
/**
 * An internal resolved representation of a factory function created by resolving {@link
 * Provider}.
 * @experimental
 */
export class ResolvedReflectiveFactory {
    /**
     * Factory function which can return an instance of an object represented by a key.
     */
    factory: Function;
    /**
     * Arguments (dependencies) to the `factory` function.
     */
    dependencies: ReflectiveDependency[];
    constructor(
        /**
         * Factory function which can return an instance of an object represented by a key.
         */
        factory: Function,
        /**
         * Arguments (dependencies) to the `factory` function.
         */
        dependencies: ReflectiveDependency[]);
}
/**
 * Resolve a list of Providers.
 */
export function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[];
/**
 * Merges a list of ResolvedProviders into a list where
 * each key is contained exactly once and multi providers
 * have been merged.
 */
export function mergeResolvedReflectiveProviders(providers: ResolvedReflectiveProvider[], normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>): Map<number, ResolvedReflectiveProvider>;
export function constructDependencies(typeOrFunc: any, dependencies?: any[]): ReflectiveDependency[];
}
declare module '@angular/core/src/di/reflective_provider' {
export * from '~@angular/core/src/di/reflective_provider';
}

// Generated by typings
// Source: node_modules/@angular/core/src/profile/profile.d.ts
declare module '~@angular/core/src/profile/profile' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { WtfScopeFn } from '~@angular/core/src/profile/wtf_impl';
export { WtfScopeFn } from '~@angular/core/src/profile/wtf_impl';
/**
 * True if WTF is enabled.
 */
export const wtfEnabled: boolean;
/**
 * Create trace scope.
 *
 * Scopes must be strictly nested and are analogous to stack frames, but
 * do not have to follow the stack frames. Instead it is recommended that they follow logical
 * nesting. You may want to use
 * [Event
 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
 * as they are defined in WTF.
 *
 * Used to mark scope entry. The return value is used to leave the scope.
 *
 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
 *
 *     someMethod() {
 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
 *        // DO SOME WORK HERE
 *        return wtfLeave(s, 123); // Return value 123
 *     }
 *
 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
 * negatively impact the performance of your application. For this reason we recommend that
 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
 * exception, will produce incorrect trace, but presence of exception signifies logic error which
 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
 * an exception is expected during normal execution while profiling.
 *
 * @experimental
 */
export const wtfCreateScope: (signature: string, flags?: any) => WtfScopeFn;
/**
 * Used to mark end of Scope.
 *
 * - `scope` to end.
 * - `returnValue` (optional) to be passed to the WTF.
 *
 * Returns the `returnValue for easy chaining.
 * @experimental
 */
export const wtfLeave: <T>(scope: any, returnValue?: T) => T;
/**
 * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
 * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
 * enabled.
 *
 *     someMethod() {
 *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
 *        var future = new Future.delay(5).then((_) {
 *          wtfEndTimeRange(s);
 *        });
 *     }
 * @experimental
 */
export const wtfStartTimeRange: (rangeType: string, action: string) => any;
/**
 * Ends a async time range operation.
 * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
 * enabled.
 * @experimental
 */
export const wtfEndTimeRange: (range: any) => void;
}
declare module '@angular/core/src/profile/profile' {
export * from '~@angular/core/src/profile/profile';
}

// Generated by typings
// Source: node_modules/@angular/core/src/profile/wtf_impl.d.ts
declare module '~@angular/core/src/profile/wtf_impl' {
/**
 * A scope function for the Web Tracing Framework (WTF).
 *
 * @experimental
 */
export interface WtfScopeFn {
    (arg0?: any, arg1?: any): any;
}
export interface Range {
}
export interface Scope {
    (...args: any[]): any;
}
export function detectWTF(): boolean;
export function createScope(signature: string, flags?: any): any;
export function leave<T>(scope: Scope): void;
export function leave<T>(scope: Scope, returnValue?: T): T;
export function startTimeRange(rangeType: string, action: string): Range;
export function endTimeRange(range: Range): void;
}
declare module '@angular/core/src/profile/wtf_impl' {
export * from '~@angular/core/src/profile/wtf_impl';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/types.d.ts
declare module '~@angular/core/src/reflection/types' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export type SetterFn = (obj: any, value: any) => void;
export type GetterFn = (obj: any) => any;
export type MethodFn = (obj: any, args: any[]) => any;
}
declare module '@angular/core/src/reflection/types' {
export * from '~@angular/core/src/reflection/types';
}

// Generated by typings
// Source: node_modules/@angular/core/src/reflection/platform_reflection_capabilities.d.ts
declare module '~@angular/core/src/reflection/platform_reflection_capabilities' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '~@angular/core/src/type';
import { GetterFn, MethodFn, SetterFn } from '~@angular/core/src/reflection/types';
export interface PlatformReflectionCapabilities {
    isReflectionEnabled(): boolean;
    factory(type: Type<any>): Function;
    hasLifecycleHook(type: any, lcProperty: string): boolean;
    parameters(type: Type<any>): any[][];
    annotations(type: Type<any>): any[];
    propMetadata(typeOrFunc: Type<any>): {
        [key: string]: any[];
    };
    getter(name: string): GetterFn;
    setter(name: string): SetterFn;
    method(name: string): MethodFn;
    importUri(type: Type<any>): string;
    resourceUri(type: Type<any>): string;
    resolveIdentifier(name: string, moduleUrl: string, members: string[] | null, runtime: any): any;
    resolveEnum(enumIdentifier: any, name: string): any;
}
}
declare module '@angular/core/src/reflection/platform_reflection_capabilities' {
export * from '~@angular/core/src/reflection/platform_reflection_capabilities';
}

// Generated by typings
// Source: node_modules/@angular/core/src/util/decorators.d.ts
declare module '~@angular/core/src/util/decorators' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Type } from '~@angular/core/src/type';
/**
 * Declares the interface to be used with {@link Class}.
 *
 * @stable
 */
export type ClassDefinition = {
    /**
     * Optional argument for specifying the superclass.
     */
    extends?: Type<any>;
    /**
     * Required constructor function for a class.
     *
     * The function may be optionally wrapped in an `Array`, in which case additional parameter
     * annotations may be specified.
     * The number of arguments and the number of parameter annotations must match.
     *
     * See {@link Class} for example of usage.
     */
    constructor: Function | any[];
} & {
    /**
     * Other methods on the class. Note that values should have type 'Function' but TS requires
     * all properties to have a narrower type than the index signature.
     */
    [x: string]: Type<any> | Function | any[];
};
/**
 * An interface implemented by all Angular type decorators, which allows them to be used as ES7
 * decorators as well as
 * Angular DSL syntax.
 *
 * DSL syntax:
 *
 * ```
 * var MyClass = ng
 *   .Component({...})
 *   .Class({...});
 * ```
 *
 * ES7 syntax:
 *
 * ```
 * @ng.Component({...})
 * class MyClass {...}
 * ```
 * @stable
 */
export interface TypeDecorator {
    /**
     * Invoke as ES7 decorator.
     */
    <T extends Type<any>>(type: T): T;
    (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;
    /**
     * Storage for the accumulated annotations so far used by the DSL syntax.
     *
     * Used by {@link Class} to annotate the generated class.
     */
    annotations: any[];
    /**
     * Generate a class from the definition and annotate it with {@link TypeDecorator#annotations}.
     */
    Class(obj: ClassDefinition): Type<any>;
}
/**
 * Provides a way for expressing ES6 classes with parameter annotations in ES5.
 *
 * ## Basic Example
 *
 * ```
 * var Greeter = ng.Class({
 *   constructor: function(name) {
 *     this.name = name;
 *   },
 *
 *   greet: function() {
 *     alert('Hello ' + this.name + '!');
 *   }
 * });
 * ```
 *
 * is equivalent to ES6:
 *
 * ```
 * class Greeter {
 *   constructor(name) {
 *     this.name = name;
 *   }
 *
 *   greet() {
 *     alert('Hello ' + this.name + '!');
 *   }
 * }
 * ```
 *
 * or equivalent to ES5:
 *
 * ```
 * var Greeter = function (name) {
 *   this.name = name;
 * }
 *
 * Greeter.prototype.greet = function () {
 *   alert('Hello ' + this.name + '!');
 * }
 * ```
 *
 * ### Example with parameter annotations
 *
 * ```
 * var MyService = ng.Class({
 *   constructor: [String, [new Optional(), Service], function(name, myService) {
 *     ...
 *   }]
 * });
 * ```
 *
 * is equivalent to ES6:
 *
 * ```
 * class MyService {
 *   constructor(name: string, @Optional() myService: Service) {
 *     ...
 *   }
 * }
 * ```
 *
 * ### Example with inheritance
 *
 * ```
 * var Shape = ng.Class({
 *   constructor: (color) {
 *     this.color = color;
 *   }
 * });
 *
 * var Square = ng.Class({
 *   extends: Shape,
 *   constructor: function(color, size) {
 *     Shape.call(this, color);
 *     this.size = size;
 *   }
 * });
 * ```
 * @suppress {globalThis}
 * @stable
 */
export function Class(clsDef: ClassDefinition): Type<any>;
/**
 * @suppress {globalThis}
 */
export function makeDecorator(name: string, props: {
    [name: string]: any;
}, parentClass?: any, chainFn?: (fn: Function) => void): (...args: any[]) => (cls: any) => any;
export function makeParamDecorator(name: string, props: ([string, any] | {
    [name: string]: any;
})[], parentClass?: any): any;
export function makePropDecorator(name: string, props: ([string, any] | {
    [key: string]: any;
})[], parentClass?: any): any;
}
declare module '@angular/core/src/util/decorators' {
export * from '~@angular/core/src/util/decorators';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/provider.d.ts
declare module '~@angular/core/src/view/provider' {
import { BindingDef, DepDef, DepFlags, NodeDef, NodeFlags, OutputDef, QueryValueType, ViewData } from '~@angular/core/src/view/types';
export function directiveDef(flags: NodeFlags, matchedQueries: [string | number, QueryValueType][], childCount: number, ctor: any, deps: ([DepFlags, any] | any)[], props?: {
    [name: string]: [number, string];
}, outputs?: {
    [name: string]: string;
}): NodeDef;
export function pipeDef(flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef;
export function providerDef(flags: NodeFlags, matchedQueries: [string | number, QueryValueType][], token: any, value: any, deps: ([DepFlags, any] | any)[]): NodeDef;
export function _def(flags: NodeFlags, matchedQueriesDsl: [string | number, QueryValueType][] | null, childCount: number, token: any, value: any, deps: ([DepFlags, any] | any)[], bindings?: BindingDef[], outputs?: OutputDef[]): NodeDef;
export function createProviderInstance(view: ViewData, def: NodeDef): any;
export function createPipeInstance(view: ViewData, def: NodeDef): any;
export function createDirectiveInstance(view: ViewData, def: NodeDef): any;
export function checkAndUpdateDirectiveInline(view: ViewData, def: NodeDef, v0: any, v1: any, v2: any, v3: any, v4: any, v5: any, v6: any, v7: any, v8: any, v9: any): boolean;
export function checkAndUpdateDirectiveDynamic(view: ViewData, def: NodeDef, values: any[]): boolean;
export const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR: {};
export function resolveDep(view: ViewData, elDef: NodeDef, allowPrivateServices: boolean, depDef: DepDef, notFoundValue?: any): any;
export function callLifecycleHooksChildrenFirst(view: ViewData, lifecycles: NodeFlags): void;
}
declare module '@angular/core/src/view/provider' {
export * from '~@angular/core/src/view/provider';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/query_list.d.ts
declare module '~@angular/core/src/linker/query_list' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Observable } from 'rxjs/Observable';
/**
 * An unmodifiable list of items that Angular keeps up to date when the state
 * of the application changes.
 *
 * The type of object that {@link ViewChildren}, {@link ContentChildren}, and {@link QueryList}
 * provide.
 *
 * Implements an iterable interface, therefore it can be used in both ES6
 * javascript `for (var i of items)` loops as well as in Angular templates with
 * `*ngFor="let i of myList"`.
 *
 * Changes can be observed by subscribing to the changes `Observable`.
 *
 * NOTE: In the future this class will implement an `Observable` interface.
 *
 * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
 * ```typescript
 * @Component({...})
 * class Container {
 *   @ViewChildren(Item) items:QueryList<Item>;
 * }
 * ```
 * @stable
 */
export class QueryList<T> {
    private _dirty;
    private _results;
    private _emitter;
    readonly changes: Observable<any>;
    readonly length: number;
    readonly first: T;
    readonly last: T;
    /**
     * See
     * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
     */
    map<U>(fn: (item: T, index: number, array: T[]) => U): U[];
    /**
     * See
     * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
     */
    filter(fn: (item: T, index: number, array: T[]) => boolean): T[];
    /**
     * See
     * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
     */
    find(fn: (item: T, index: number, array: T[]) => boolean): T | undefined;
    /**
     * See
     * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
     */
    reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U;
    /**
     * See
     * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
     */
    forEach(fn: (item: T, index: number, array: T[]) => void): void;
    /**
     * See
     * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
     */
    some(fn: (value: T, index: number, array: T[]) => boolean): boolean;
    toArray(): T[];
    toString(): string;
    reset(res: Array<T | any[]>): void;
    notifyOnChanges(): void;
    /** internal */
    setDirty(): void;
    /** internal */
    readonly dirty: boolean;
}
}
declare module '@angular/core/src/linker/query_list' {
export * from '~@angular/core/src/linker/query_list';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/template_ref.d.ts
declare module '~@angular/core/src/linker/template_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ElementRef } from '~@angular/core/src/linker/element_ref';
import { EmbeddedViewRef } from '~@angular/core/src/linker/view_ref';
/**
 * Represents an Embedded Template that can be used to instantiate Embedded Views.
 *
 * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<ng-template>` element
 * (or directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into
 * the constructor of the directive using the `TemplateRef` Token. Alternatively you can query for
 * the `TemplateRef` from a Component or a Directive via {@link Query}.
 *
 * To instantiate Embedded Views based on a Template, use
 * {@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
 * View Container.
 * @stable
 */
export abstract class TemplateRef<C> {
    /**
     * The location in the View where the Embedded View logically belongs to.
     *
     * The data-binding and injection contexts of Embedded Views created from this `TemplateRef`
     * inherit from the contexts of this location.
     *
     * Typically new Embedded Views are attached to the View Container of this location, but in
     * advanced use-cases, the View can be attached to a different container while keeping the
     * data-binding and injection context from the original location.
     *
     */
    readonly abstract elementRef: ElementRef;
    abstract createEmbeddedView(context: C): EmbeddedViewRef<C>;
}
}
declare module '@angular/core/src/linker/template_ref' {
export * from '~@angular/core/src/linker/template_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/linker/view_container_ref.d.ts
declare module '~@angular/core/src/linker/view_container_ref' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injector } from '~@angular/core/src/di/injector';
import { ComponentFactory, ComponentRef } from '~@angular/core/src/linker/component_factory';
import { ElementRef } from '~@angular/core/src/linker/element_ref';
import { NgModuleRef } from '~@angular/core/src/linker/ng_module_factory';
import { TemplateRef } from '~@angular/core/src/linker/template_ref';
import { EmbeddedViewRef, ViewRef } from '~@angular/core/src/linker/view_ref';
/**
 * Represents a container where one or more Views can be attached.
 *
 * The container can contain two kinds of Views. Host Views, created by instantiating a
 * {@link Component} via {@link #createComponent}, and Embedded Views, created by instantiating an
 * {@link TemplateRef Embedded Template} via {@link #createEmbeddedView}.
 *
 * The location of the View Container within the containing View is specified by the Anchor
 * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
 * have a single View Container.
 *
 * Root elements of Views attached to this container become siblings of the Anchor Element in
 * the Rendered View.
 *
 * To access a `ViewContainerRef` of an Element, you can either place a {@link Directive} injected
 * with `ViewContainerRef` on the Element, or you obtain it via a {@link ViewChild} query.
 * @stable
 */
export abstract class ViewContainerRef {
    /**
     * Anchor element that specifies the location of this container in the containing View.
     * <!-- TODO: rename to anchorElement -->
     */
    readonly abstract element: ElementRef;
    readonly abstract injector: Injector;
    readonly abstract parentInjector: Injector;
    /**
     * Destroys all Views in this container.
     */
    abstract clear(): void;
    /**
     * Returns the {@link ViewRef} for the View located in this container at the specified index.
     */
    abstract get(index: number): ViewRef | null;
    /**
     * Returns the number of Views currently attached to this container.
     */
    readonly abstract length: number;
    /**
     * Instantiates an Embedded View based on the {@link TemplateRef `templateRef`} and inserts it
     * into this container at the specified `index`.
     *
     * If `index` is not specified, the new View will be inserted as the last View in the container.
     *
     * Returns the {@link ViewRef} for the newly created View.
     */
    abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;
    /**
     * Instantiates a single {@link Component} and inserts its Host View into this container at the
     * specified `index`.
     *
     * The component is instantiated using its {@link ComponentFactory} which can be
     * obtained via {@link ComponentFactoryResolver#resolveComponentFactory}.
     *
     * If `index` is not specified, the new View will be inserted as the last View in the container.
     *
     * You can optionally specify the {@link Injector} that will be used as parent for the Component.
     *
     * Returns the {@link ComponentRef} of the Host View created for the newly instantiated Component.
     */
    abstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, projectableNodes?: any[][], ngModule?: NgModuleRef<any>): ComponentRef<C>;
    /**
     * Inserts a View identified by a {@link ViewRef} into the container at the specified `index`.
     *
     * If `index` is not specified, the new View will be inserted as the last View in the container.
     *
     * Returns the inserted {@link ViewRef}.
     */
    abstract insert(viewRef: ViewRef, index?: number): ViewRef;
    /**
     * Moves a View identified by a {@link ViewRef} into the container at the specified `index`.
     *
     * Returns the inserted {@link ViewRef}.
     */
    abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;
    /**
     * Returns the index of the View, specified via {@link ViewRef}, within the current container or
     * `-1` if this container doesn't contain the View.
     */
    abstract indexOf(viewRef: ViewRef): number;
    /**
     * Destroys a View attached to this container at the specified `index`.
     *
     * If `index` is not specified, the last View in the container will be removed.
     */
    abstract remove(index?: number): void;
    /**
     * Use along with {@link #insert} to move a View within the current container.
     *
     * If the `index` param is omitted, the last {@link ViewRef} is detached.
     */
    abstract detach(index?: number): ViewRef | null;
}
}
declare module '@angular/core/src/linker/view_container_ref' {
export * from '~@angular/core/src/linker/view_container_ref';
}

// Generated by typings
// Source: node_modules/@angular/core/src/render/api.d.ts
declare module '~@angular/core/src/render/api' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { InjectionToken, Injector } from '~@angular/core/src/di';
import { ViewEncapsulation } from '~@angular/core/src/metadata/view';
/**
 * @deprecated Use `RendererType2` (and `Renderer2`) instead.
 */
export class RenderComponentType {
    id: string;
    templateUrl: string;
    slotCount: number;
    encapsulation: ViewEncapsulation;
    styles: Array<string | any[]>;
    animations: any;
    constructor(id: string, templateUrl: string, slotCount: number, encapsulation: ViewEncapsulation, styles: Array<string | any[]>, animations: any);
}
/**
 * @deprecated Debug info is handeled internally in the view engine now.
 */
export abstract class RenderDebugInfo {
    readonly abstract injector: Injector;
    readonly abstract component: any;
    readonly abstract providerTokens: any[];
    readonly abstract references: {
        [key: string]: any;
    };
    readonly abstract context: any;
    readonly abstract source: string;
}
/**
 * @deprecated Use the `Renderer2` instead.
 */
export interface DirectRenderer {
    remove(node: any): void;
    appendChild(node: any, parent: any): void;
    insertBefore(node: any, refNode: any): void;
    nextSibling(node: any): any;
    parentElement(node: any): any;
}
/**
 * @deprecated Use the `Renderer2` instead.
 */
export abstract class Renderer {
    abstract selectRootElement(selectorOrNode: string | any, debugInfo?: RenderDebugInfo): any;
    abstract createElement(parentElement: any, name: string, debugInfo?: RenderDebugInfo): any;
    abstract createViewRoot(hostElement: any): any;
    abstract createTemplateAnchor(parentElement: any, debugInfo?: RenderDebugInfo): any;
    abstract createText(parentElement: any, value: string, debugInfo?: RenderDebugInfo): any;
    abstract projectNodes(parentElement: any, nodes: any[]): void;
    abstract attachViewAfter(node: any, viewRootNodes: any[]): void;
    abstract detachView(viewRootNodes: any[]): void;
    abstract destroyView(hostElement: any, viewAllNodes: any[]): void;
    abstract listen(renderElement: any, name: string, callback: Function): Function;
    abstract listenGlobal(target: string, name: string, callback: Function): Function;
    abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: any): void;
    abstract setElementAttribute(renderElement: any, attributeName: string, attributeValue: string): void;
    /**
     * Used only in debug mode to serialize property changes to dom nodes as attributes.
     */
    abstract setBindingDebugInfo(renderElement: any, propertyName: string, propertyValue: string): void;
    abstract setElementClass(renderElement: any, className: string, isAdd: boolean): void;
    abstract setElementStyle(renderElement: any, styleName: string, styleValue: string): void;
    abstract invokeElementMethod(renderElement: any, methodName: string, args?: any[]): void;
    abstract setText(renderNode: any, text: string): void;
    abstract animate(element: any, startingStyles: any, keyframes: any[], duration: number, delay: number, easing: string, previousPlayers?: any[]): any;
}
export const Renderer2Interceptor: InjectionToken<Renderer2[]>;
/**
 * Injectable service that provides a low-level interface for modifying the UI.
 *
 * Use this service to bypass Angular's templating and make custom UI changes that can't be
 * expressed declaratively. For example if you need to set a property or an attribute whose name is
 * not statically known, use {@link Renderer#setElementProperty} or {@link
 * Renderer#setElementAttribute}
 * respectively.
 *
 * If you are implementing a custom renderer, you must implement this interface.
 *
 * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
 *
 * @deprecated Use `RendererFactory2` instead.
 */
export abstract class RootRenderer {
    abstract renderComponent(componentType: RenderComponentType): Renderer;
}
/**
 * @experimental
 */
export interface RendererType2 {
    id: string;
    encapsulation: ViewEncapsulation;
    styles: (string | any[])[];
    data: {
        [kind: string]: any;
    };
}
/**
 * @experimental
 */
export abstract class RendererFactory2 {
    abstract createRenderer(hostElement: any, type: RendererType2 | null): Renderer2;
}
/**
 * @experimental
 */
export enum RendererStyleFlags2 {
    Important = 1,
    DashCase = 2,
}
/**
 * @experimental
 */
export abstract class Renderer2 {
    /**
     * This field can be used to store arbitrary data on this renderer instance.
     * This is useful for renderers that delegate to other renderers.
     */
    readonly abstract data: {
        [key: string]: any;
    };
    abstract destroy(): void;
    abstract createElement(name: string, namespace?: string | null): any;
    abstract createComment(value: string): any;
    abstract createText(value: string): any;
    /**
     * This property is allowed to be null / undefined,
     * in which case the view engine won't call it.
     * This is used as a performance optimization for production mode.
     */
    destroyNode: ((node: any) => void) | null;
    abstract appendChild(parent: any, newChild: any): void;
    abstract insertBefore(parent: any, newChild: any, refChild: any): void;
    abstract removeChild(parent: any, oldChild: any): void;
    abstract selectRootElement(selectorOrNode: string | any): any;
    /**
     * Attention: On WebWorkers, this will always return a value,
     * as we are asking for a result synchronously. I.e.
     * the caller can't rely on checking whether this is null or not.
     */
    abstract parentNode(node: any): any;
    /**
     * Attention: On WebWorkers, this will always return a value,
     * as we are asking for a result synchronously. I.e.
     * the caller can't rely on checking whether this is null or not.
     */
    abstract nextSibling(node: any): any;
    abstract setAttribute(el: any, name: string, value: string, namespace?: string | null): void;
    abstract removeAttribute(el: any, name: string, namespace?: string | null): void;
    abstract addClass(el: any, name: string): void;
    abstract removeClass(el: any, name: string): void;
    abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;
    abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;
    abstract setProperty(el: any, name: string, value: any): void;
    abstract setValue(node: any, value: string): void;
    abstract listen(target: 'window' | 'document' | 'body' | any, eventName: string, callback: (event: any) => boolean | void): () => void;
}
}
declare module '@angular/core/src/render/api' {
export * from '~@angular/core/src/render/api';
}

// Generated by typings
// Source: node_modules/@angular/core/src/view/types.d.ts
declare module '~@angular/core/src/view/types' {
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { Injector } from '~@angular/core/src/di';
import { ErrorHandler } from '~@angular/core/src/error_handler';
import { NgModuleRef } from '~@angular/core/src/linker/ng_module_factory';
import { QueryList } from '~@angular/core/src/linker/query_list';
import { TemplateRef } from '~@angular/core/src/linker/template_ref';
import { ViewContainerRef } from '~@angular/core/src/linker/view_container_ref';
import { Renderer2, RendererFactory2, RendererType2 } from '~@angular/core/src/render/api';
import { Sanitizer, SecurityContext } from '~@angular/core/src/security';
export interface ViewDefinition {
    factory: ViewDefinitionFactory | null;
    flags: ViewFlags;
    updateDirectives: ViewUpdateFn;
    updateRenderer: ViewUpdateFn;
    handleEvent: ViewHandleEventFn;
    /**
     * Order: Depth first.
     * Especially providers are before elements / anchors.
     */
    nodes: NodeDef[];
    /** aggregated NodeFlags for all nodes **/
    nodeFlags: NodeFlags;
    rootNodeFlags: NodeFlags;
    lastRenderRootNode: NodeDef | null;
    bindingCount: number;
    outputCount: number;
    /**
     * Binary or of all query ids that are matched by one of the nodes.
     * This includes query ids from templates as well.
     * Used as a bloom filter.
     */
    nodeMatchedQueries: number;
}
/**
 * Factory for ViewDefinitions.
 * We use a function so we can reexeute it in case an error happens and use the given logger
 * function to log the error from the definition of the node, which is shown in all browser
 * logs.
 */
export interface ViewDefinitionFactory {
    (logger: NodeLogger): ViewDefinition;
}
/**
 * Function to call console.error at the right source location. This is an indirection
 * via another function as browser will log the location that actually called
 * `console.error`.
 */
export interface NodeLogger {
    (): () => void;
}
export interface ViewUpdateFn {
    (check: NodeCheckFn, view: ViewData): void;
}
export interface NodeCheckFn {
    (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Dynamic, values: any[]): any;
    (view: ViewData, nodeIndex: number, argStyle: ArgumentType.Inline, v0?: any, v1?: any, v2?: any, v3?: any, v4?: any, v5?: any, v6?: any, v7?: any, v8?: any, v9?: any): any;
}
export const enum ArgumentType {
    Inline = 0,
    Dynamic = 1,
}
export interface ViewHandleEventFn {
    (view: ViewData, nodeIndex: number, eventName: string, event: any): boolean;
}
/**
 * Bitmask for ViewDefintion.flags.
 */
export const enum ViewFlags {
    None = 0,
    OnPush = 2,
}
/**
 * A node definition in the view.
 *
 * Note: We use one type for all nodes so that loops that loop over all nodes
 * of a ViewDefinition stay monomorphic!
 */
export interface NodeDef {
    flags: NodeFlags;
    index: number;
    parent: NodeDef | null;
    renderParent: NodeDef | null;
    /** this is checked against NgContentDef.index to find matched nodes */
    ngContentIndex: number;
    /** number of transitive children */
    childCount: number;
    /** aggregated NodeFlags for all transitive children (does not include self) **/
    childFlags: NodeFlags;
    /** aggregated NodeFlags for all direct children (does not include self) **/
    directChildFlags: NodeFlags;
    bindingIndex: number;
    bindings: BindingDef[];
    bindingFlags: BindingFlags;
    outputIndex: number;
    outputs: OutputDef[];
    /**
     * references that the user placed on the element
     */
    references: {
        [refId: string]: QueryValueType;
    };
    /**
     * ids and value types of all queries that are matched by this node.
     */
    matchedQueries: {
        [queryId: number]: QueryValueType;
    };
    /** Binary or of all matched query ids of this node. */
    matchedQueryIds: number;
    /**
     * Binary or of all query ids that are matched by one of the children.
     * This includes query ids from templates as well.
     * Used as a bloom filter.
     */
    childMatchedQueries: number;
    element: ElementDef | null;
    provider: ProviderDef | null;
    text: TextDef | null;
    query: QueryDef | null;
    ngContent: NgContentDef | null;
}
/**
 * Bitmask for NodeDef.flags.
 * Naming convention:
 * - `Type...`: flags that are mutually exclusive
 * - `Cat...`: union of multiple `Type...` (short for category).
 */
export const enum NodeFlags {
    None = 0,
    TypeElement = 1,
    TypeText = 2,
    ProjectedTemplate = 4,
    CatRenderNode = 3,
    TypeNgContent = 8,
    TypePipe = 16,
    TypePureArray = 32,
    TypePureObject = 64,
    TypePurePipe = 128,
    CatPureExpression = 224,
    TypeValueProvider = 256,
    TypeClassProvider = 512,
    TypeFactoryProvider = 1024,
    TypeUseExistingProvider = 2048,
    LazyProvider = 4096,
    PrivateProvider = 8192,
    TypeDirective = 16384,
    Component = 32768,
    CatProvider = 20224,
    OnInit = 65536,
    OnDestroy = 131072,
    DoCheck = 262144,
    OnChanges = 524288,
    AfterContentInit = 1048576,
    AfterContentChecked = 2097152,
    AfterViewInit = 4194304,
    AfterViewChecked = 8388608,
    EmbeddedViews = 16777216,
    ComponentView = 33554432,
    TypeContentQuery = 67108864,
    TypeViewQuery = 134217728,
    StaticQuery = 268435456,
    DynamicQuery = 536870912,
    CatQuery = 201326592,
    Types = 201347067,
}
export interface BindingDef {
    flags: BindingFlags;
    ns: string | null;
    name: string | null;
    nonMinifiedName: string | null;
    securityContext: SecurityContext | null;
    suffix: string | null;
}
export const enum BindingFlags {
    TypeElementAttribute = 1,
    TypeElementClass = 2,
    TypeElementStyle = 4,
    TypeProperty = 8,
    SyntheticProperty = 16,
    SyntheticHostProperty = 32,
    CatSyntheticProperty = 48,
    Types = 15,
}
export interface OutputDef {
    type: OutputType;
    target: 'window' | 'document' | 'body' | 'component' | null;
    eventName: string;
    propName: string | null;
}
export const enum OutputType {
    ElementOutput = 0,
    DirectiveOutput = 1,
}
export const enum QueryValueType {
    ElementRef = 0,
    RenderElement = 1,
    TemplateRef = 2,
    ViewContainerRef = 3,
    Provider = 4,
}
export interface ElementDef {
    name: string | null;
    ns: string | null;
    /** ns, name, value */
    attrs: [string, string, string][] | null;
    template: ViewDefinition | null;
    componentProvider: NodeDef | null;
    componentRendererType: RendererType2 | null;
    componentView: ViewDefinitionFactory | null;
    /**
     * visible public providers for DI in the view,
     * as see from this element. This does not include private providers.
     */
    publicProviders: {
        [tokenKey: string]: NodeDef;
    } | null;
    /**
     * same as visiblePublicProviders, but also includes private providers
     * that are located on this element.
     */
    allProviders: {
        [tokenKey: string]: NodeDef;
    } | null;
    handleEvent: ElementHandleEventFn | null;
}
export interface ElementHandleEventFn {
    (view: ViewData, eventName: string, event: any): boolean;
}
export interface ProviderDef {
    token: any;
    tokenKey: string;
    value: any;
    deps: DepDef[];
}
export interface DepDef {
    flags: DepFlags;
    token: any;
    tokenKey: string;
}
/**
 * Bitmask for DI flags
 */
export const enum DepFlags {
    None = 0,
    SkipSelf = 1,
    Optional = 2,
    Value = 8,
}
export interface TextDef {
    prefix: string;
}
export interface QueryDef {
    id: number;
    filterId: number;
    bindings: QueryBindingDef[];
}
export interface QueryBindingDef {
    propName: string;
    bindingType: QueryBindingType;
}
export const enum QueryBindingType {
    First = 0,
    All = 1,
}
export interface NgContentDef {
    /**
     * this index is checked against NodeDef.ngContentIndex to find the nodes
     * that are matched by this ng-content.
     * Note that a NodeDef with an ng-content can be reprojected, i.e.
     * have a ngContentIndex on its own.
     */
    index: number;
}
/**
 * View instance data.
 * Attention: Adding fields to this is performance sensitive!
 */
export interface ViewData {
    def: ViewDefinition;
    root: RootData;
    renderer: Renderer2;
    parentNodeDef: NodeDef | null;
    parent: ViewData | null;
    viewContainerParent: ViewData | null;
    component: any;
    context: any;
    nodes: {
        [key: number]: NodeData;
    };
    state: ViewState;
    oldValues: any[];
    disposables: DisposableFn[] | null;
}
/**
 * Bitmask of states
 */
export const enum ViewState {
    BeforeFirstCheck = 1,
    FirstCheck = 2,
    Attached = 4,
    ChecksEnabled = 8,
    IsProjectedView = 16,
    CheckProjectedView = 32,
    CheckProjectedViews = 64,
    Destroyed = 128,
    CatDetectChanges = 12,
    CatInit = 13,
}
export interface DisposableFn {
    (): void;
}
/**
 * Node instance data.
 *
 * We have a separate type per NodeType to save memory
 * (TextData | ElementData | ProviderData | PureExpressionData | QueryList<any>)
 *
 * To keep our code monomorphic,
 * we prohibit using `NodeData` directly but enforce the use of accessors (`asElementData`, ...).
 * This way, no usage site can get a `NodeData` from view.nodes and then use it for different
 * purposes.
 */
export class NodeData {
    private __brand;
}
/**
 * Data for an instantiated NodeType.Text.
 *
 * Attention: Adding fields to this is performance sensitive!
 */
export interface TextData {
    renderText: any;
}
/**
 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
 */
export function asTextData(view: ViewData, index: number): TextData;
/**
 * Data for an instantiated NodeType.Element.
 *
 * Attention: Adding fields to this is performance sensitive!
 */
export interface ElementData {
    renderElement: any;
    componentView: ViewData;
    viewContainer: ViewContainerData | null;
    template: TemplateData;
}
export interface ViewContainerData extends ViewContainerRef {
    _embeddedViews: ViewData[];
}
export interface TemplateData extends TemplateRef<any> {
    _projectedViews: ViewData[];
}
/**
 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
 */
export function asElementData(view: ViewData, index: number): ElementData;
/**
 * Data for an instantiated NodeType.Provider.
 *
 * Attention: Adding fields to this is performance sensitive!
 */
export interface ProviderData {
    instance: any;
}
/**
 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
 */
export function asProviderData(view: ViewData, index: number): ProviderData;
/**
 * Data for an instantiated NodeType.PureExpression.
 *
 * Attention: Adding fields to this is performance sensitive!
 */
export interface PureExpressionData {
    value: any;
}
/**
 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
 */
export function asPureExpressionData(view: ViewData, index: number): PureExpressionData;
/**
 * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
 */
export function asQueryList(view: ViewData, index: number): QueryList<any>;
export interface RootData {
    injector: Injector;
    ngModule: NgModuleRef<any>;
    projectableNodes: any[][];
    selectorOrNode: any;
    renderer: Renderer2;
    rendererFactory: RendererFactory2;
    errorHandler: ErrorHandler;
    sanitizer: Sanitizer;
}
export abstract class DebugContext {
    readonly abstract view: ViewData;
    readonly abstract nodeIndex: number | null;
    readonly abstract injector: Injector;
    readonly abstract component: any;
    readonly abstract providerTokens: any[];
    readonly abstract references: {
        [key: string]: any;
    };
    readonly abstract context: any;
    readonly abstract componentRenderElement: any;
    readonly abstract renderNode: any;
    abstract logError(console: Console, ...values: any[]): void;
}
export const enum CheckType {
    CheckAndUpdate = 0,
    CheckNoChanges = 1,
}
export interface Services {
    setCurrentNode(view: ViewData, nodeIndex: number): void;
    createRootView(injector: Injector, projectableNodes: any[][], rootSelectorOrNode: string | any, def: ViewDefinition, ngModule: NgModuleRef<any>, context?: any): ViewData;
    createEmbeddedView(parent: ViewData, anchorDef: NodeDef, context?: any): ViewData;
    checkAndUpdateView(view: ViewData): void;
    checkNoChangesView(view: ViewData): void;
    destroyView(view: ViewData): void;
    resolveDep(view: ViewData, elDef: NodeDef | null, allowPrivateServices: boolean, depDef: DepDef, notFoundValue?: any): any;
    createDebugContext(view: ViewData, nodeIndex: number): DebugContext;
    handleEvent: ViewHandleEventFn;
    updateDirectives: (view: ViewData, checkType: CheckType) => void;
    updateRenderer: (view: ViewData, checkType: CheckType) => void;
    dirtyParentQueries: (view: ViewData) => void;
}
/**
 * This object is used to prevent cycles in the source files and to have a place where
 * debug mode can hook it. It is lazily filled when `isDevMode` is known.
 */
export const Services: Services;
}
declare module '@angular/core/src/view/types' {
export * from '~@angular/core/src/view/types';
}

// Generated by typings
// Source: node_modules/@angular/core/core.d.ts
declare module '~@angular/core/core' {
/**
 * Generated bundle index. Do not edit.
 */
export * from '~@angular/core/public_api';
export { AnimationMetadataType as ɵy, animate as ɵba, group as ɵbb, keyframes as ɵbf, sequence as ɵbc, state as ɵbe, style as ɵbd, transition as ɵbg, trigger as ɵz } from '~@angular/core/src/animation/dsl';
export { _initViewEngine as ɵo, _iterableDiffersFactory as ɵl, _keyValueDiffersFactory as ɵm, _localeFactory as ɵn } from '~@angular/core/src/application_module';
export { ApplicationRef_ as ɵf } from '~@angular/core/src/application_ref';
export { _appIdRandomProviderFactory as ɵg } from '~@angular/core/src/application_tokens';
export { defaultIterableDiffers as ɵh, defaultKeyValueDiffers as ɵi } from '~@angular/core/src/change_detection/change_detection';
export { DefaultIterableDifferFactory as ɵj } from '~@angular/core/src/change_detection/differs/default_iterable_differ';
export { DefaultKeyValueDifferFactory as ɵk } from '~@angular/core/src/change_detection/differs/default_keyvalue_differ';
export { ReflectiveInjector_ as ɵc } from '~@angular/core/src/di/reflective_injector';
export { ReflectiveDependency as ɵd, resolveReflectiveProviders as ɵe } from '~@angular/core/src/di/reflective_provider';
export { wtfEnabled as ɵp } from '~@angular/core/src/profile/profile';
export { createScope as ɵr, detectWTF as ɵq, endTimeRange as ɵu, leave as ɵs, startTimeRange as ɵt } from '~@angular/core/src/profile/wtf_impl';
export { PlatformReflectionCapabilities as ɵv } from '~@angular/core/src/reflection/platform_reflection_capabilities';
export { makeParamDecorator as ɵa, makePropDecorator as ɵb } from '~@angular/core/src/util/decorators';
export { _def as ɵw } from '~@angular/core/src/view/provider';
export { DebugContext as ɵx } from '~@angular/core/src/view/types';
}
declare module '@angular/core/core' {
export * from '~@angular/core/core';
}
declare module '@angular/core' {
export * from '~@angular/core/core';
}
